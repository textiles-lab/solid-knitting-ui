<!DOCTYPE html>
<html>
<head>
<title>Solid Knitting UI</title>
<style>
body {
	padding:0;
	margin:0;
}
#dropTarget {
	position:fixed;
	left:0;
	bottom:0;
	width:100%;
	height:100%;

	background:#ccc;
	outline:4px dashed #eee;
	outline-offset:-20px;
	z-index:100;
	visibility:hidden;
}
#dropTarget.active {
	visibility:visible;
	background:#eee;
	outline-color:#ccc;
}
#file {
	display:none;
}

#views {
	display:grid;
	width:99vw;
	height:99vh;

	grid-template-columns: 1fr auto ;
	grid-template-rows: auto 1.0fr ;

	/*background: #0008 ;*/
}
#controls {
	grid-column: 1 / 3 ;
	grid-row: 1 ;
	font-size: 16px;
	line-height:16px;
	padding: 5px 10px;
	display:flex;
	flex-flow: row wrap;
	align-items:center;
	/*background: #f008 ;*/
}

.controlsButton {
	box-sizing:border-box;
	cursor:pointer;
	display:block;
	background:#cfbb96;
	padding:4px 8px;
	margin:0 2px;
	box-shadow: 0 1px 2px 0 #0008;
	text-decoration:none;
	line-height:1;
	border: none;
	border-radius:2px;
	height:100%;
	font-size:inherit;
}

.controlsButton:hover {
	background:#f6d69b;
}

.controlsButton:active {
	box-shadow: 0 0 1px 0 #0008;
}

#view-3d {
	grid-column: 1 ;
	grid-row: 2 ;
	position:relative;
	/*background: #0f08 ;*/
}
#canvas {
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
}
#view-library {
	grid-column: 2 ;
	grid-row: 2 ;
	/*background: #00f8 ;*/
}
#view-library h1 {
	font-size:20px;
	line-height:20px;
	padding:0;
	margin:0 5px;
}
#library {
	display:block;
	list-style:none;
	margin:0;
	padding:0;
}
#library li {
	display:block;
	margin:0.5em 1.0em;
	padding:0;
}
</style>
</head>
<body>

<div id="views">

<!-- controls bar at the top of the window -->
<div id="controls">
<input id="file" type="file" />
<label id="fileLabel" for="file" class="controlsButton">Load</label>
<span id="fileName">(no file loaded)</span>
<!-- <button id="benchmark">benchmark</button>
<span id="benchmark-result"></span> -->
<button id="save" class="controlsButton">Save</button>
</div>

<!-- 3d view -->
<div id="view-3d">
<canvas id="canvas" width="120" height="120"></canvas>
</div>

<!-- library panel -->
<div id="view-library">
<h1>Blocks:</h1>
<ul id="library">
</ul>
</div>

</div>

<!-- full-window drop target -->
<div id="dropTarget"></div>

<!-- File loading code -->
<script>
// TODO: Consider moving each script into its own module for the sake of code
// clarity. 
//-----------------------------------------------------------------------------
// File loading code

window.currentFile = null;

function setFilename(name) {
	document.getElementById("fileName").textContent = name;
}
function readFile(file) {
	console.log("Attempting to read file: '" + file.name + "'");
	setFilename(file.name);

	if (readFile.reader) {
		readFile.reader.abort();
		delete readFile.reader;
	}

	let reader = readFile.reader = new FileReader();
	reader.onload = function(){
		console.log("File was " + reader.result.byteLength + " bytes long.");
		window.body = sv.Body.fromArrayBuffer(reader.result, library);

		bodyDirty();
		mouseDirty();
		resetCamera();
		requestRedraw();
		window.currentFile = file;
	};
	reader.readAsArrayBuffer(file);
}

var dropTarget = document.getElementById("dropTarget");
//dragging into the window also loads files:
dropTarget.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('dragleave', function(evt){
	dropTarget.classList.remove("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('drop', function(evt){
	dropTarget.classList.remove("active");
	try {
		file.value = "";
		window.currentFile = null;
		readFile(evt.dataTransfer.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});

//dragging into the window shows the target:
document.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});

var file = document.getElementById("file");
file.addEventListener('change', function(evt){
	try {
		window.currentFile = null;
		readFile(file.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});
file.addEventListener('click', function(evt){
	file.value = ""; //reset so 'change' event fires
});

document.getElementById("save").addEventListener('click', function(evt){
	console.log("Saving");
	const text = JSON.stringify(body.toData());
	fileSave(text, "solid-knitting.body");
});

//from knitout-live-visualizer:
function fileSave(sourceText, fileIdentity) {
	var workElement = document.createElement("a");
	if ('download' in workElement) {
		workElement.href = "data:" + 'text/plain' + "charset=utf-8," + escape(sourceText);
		workElement.setAttribute("download", fileIdentity);
		document.body.appendChild(workElement);
		var eventMouse = document.createEvent("MouseEvents");
		eventMouse.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
		workElement.dispatchEvent(eventMouse);
		document.body.removeChild(workElement);
	} else throw 'File saving not supported for this browser';
}

</script>

<!-- Solid Knitting UI code -->
<script type="module">
'use strict';

import * as gm from './code/gm.mjs';
window.gm = gm; //DEBUG

import * as sv from './code/sv.mjs';
window.sv = sv; //DEBUG

window.library = new sv.Library();
window.template = null;
window.body = new sv.Body();

import {Geometry, Program} from './code/gl.mjs';

//-----------------------------------------------------------------------------
// Adapted from yarn visualizer code (from smobj)
// NOTE: based largely on the MDN WebGL tutorials at:
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL

const canvas = document.getElementById("canvas");
const gl = canvas.getContext('webgl', {alpha:false});
window.gl = gl; //DEBUG

//------- camera -------
const camera = {
	target:gm.vec3(0),
	radius:2.5,
	azimuth:0.0,
	elevation:0.0,
	fovy:45.0,
	aspect:1.0
};

window.camera = camera; //DEBUG

camera.computeUp = function camera_computeUp() {
	return gm.vec3(
		Math.cos(this.azimuth)*-Math.sin(this.elevation),
		Math.sin(this.azimuth)*-Math.sin(this.elevation),
		Math.cos(this.elevation)
	);
};

camera.computeRight = function camera_computeRight() {
	return gm.vec3(
		-Math.sin(this.azimuth),
		Math.cos(this.azimuth),
		0.0
	);
};

camera.computeOut = function camera_computeOut() {
	return gm.vec3(
		Math.cos(this.azimuth)*Math.cos(this.elevation),
		Math.sin(this.azimuth)*Math.cos(this.elevation),
		Math.sin(this.elevation)
	);
};

camera.computeAt = function camera_computeAt() {
	return gm.add(this.target, gm.scale(this.radius, this.computeOut()));
};

function resetCamera() {
	let min = gm.vec3(Infinity);
	let max = gm.vec3(-Infinity);

	//TOOD: compute bounding box

	if (min[0] > max[0]) {
		//for now, just some default:
		min[0] = -10.0; min[1] = -10.0; min[2] = -10.0;
		max[0] =  10.0; max[1] =  10.0; max[2] =  10.0;
	}

	camera.target = gm.scale(0.5, gm.add(min,max));

	//console.log("Range: ",min,max);

	camera.radius = 0.5 * (max[1] - min[1]) / Math.tan(0.5 * camera.fovy * Math.PI / 180.0) + 0.5 * (max[2] - min[2]);
	camera.azimuth = Math.PI / 6.0;
	camera.elevation = Math.PI / 4.0;

	requestRedraw();
}
window.resetCamera = resetCamera;

//--- controls ---

const MOUSE = {x:NaN, y:NaN, over:null, grid:null};
let ACTION = null; //<-- current action; gets all events if not null

let camFlipX = false; //used for camera rotation control

function mouseRay() {
	const origin = camera.computeAt();

	//compute ray direction through mouse:
	const o = camera.computeOut();
	const r = camera.computeRight();
	const u = camera.computeUp();
	const rh = Math.tan(0.5 * camera.fovy / 180.0 * Math.PI); //half of the image plane height
	const rw = rh * camera.aspect; //half of the image plane width

	const direction = gm.sub( gm.add( gm.scale(rw * MOUSE.x, r), gm.scale(rh * MOUSE.y, u)), o);

	return {origin, direction};
}

function mouseDirty() {
	MOUSE.over = null;
	MOUSE.grid = null;

	MOUSE.dirty = true;
	requestRedraw(); //mouse will be updated as part of redraw
}
window.mouseDirty = mouseDirty;

function bodyDirty() {
	visBody.dirty = true;
	visWire.dirty = true;
	requestRedraw();
}
window.bodyDirty = bodyDirty;

function setMouseOver() {
	MOUSE.over = null;
	MOUSE.grid = null;
	if (MOUSE.x !== MOUSE.x) return;
	const ray = mouseRay();

	let close = Infinity;
	

	//faces of cells:
	function isect(a,b,c, cell,face) {
		const perp = gm.cross(gm.sub(b, a), gm.sub(c, a));

		//offset of the start of the ray from the plane of the triangle:
		const ofs = gm.dot(perp, gm.sub(ray.origin, a));

		//change in offset when moving along direction:
		const step = gm.dot(perp, ray.direction);

		//if can't get to plane of triangle, can't intersect:
		if (step === 0) return;
		if (ofs <= 0 && step <= 0) return;
		if (ofs >= 0 && step >= 0) return;

		//if can't get to plane in time, can't intersect:
		const t = -ofs / step;
		if (t >= close) return;

		//move point to plane of triangle:
		const p = gm.add(ray.origin, gm.scale(t, ray.direction));

		//console.log(`Close to zero(?): ${dot(perp, sub(p,a))}`); //DEBUG

		//barycentric coords:
		const wa = gm.dot(perp, gm.cross(gm.sub(c,b), gm.sub(p,b)));
		const wb = gm.dot(perp, gm.cross(gm.sub(a,c), gm.sub(p,c)));
		const wc = gm.dot(perp, gm.cross(gm.sub(b,a), gm.sub(p,a)));

		//outside the triangle:
		if (wa < 0 || wb < 0 || wc < 0) return;

		close = t;
		MOUSE.over = {cell, face};
		MOUSE.grid = null;
	}

	for (const cell of body.cells) {
		{ //ray vs bounding box of cell:
			let min = gm.vec3(Infinity);
			let max = gm.vec3(-Infinity);
			for (let v of cell.vertices) {
				min = gm.min(min, v);
				max = gm.max(max, v);
			}
			let t0 = 0;
			let t1 = Infinity;
			function reduce(low, high, origin, direction) {
				//when is low <= origin + t * direction <= high?
				if (direction > 0) {
					t0 = Math.max(t0, (low - origin) / direction);
					t1 = Math.min(t1, (high - origin) / direction);
				} else if (direction < 0) {
					t1 = Math.min(t1, (low - origin) / direction);
					t0 = Math.max(t0, (high - origin) / direction);
				} else {
					if (origin < low || origin > high) {
						t0 = 1;
						t1 = 0;
					}
				}
			}
			for (let d = 0; d < 3; ++d) {
				reduce(min[d], max[d], ray.origin[d], ray.direction[d]);
			}
			if (t0 > t1) continue; //if doesn't intersect bounding box
		}

		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			const face = cell.template.faces[fi];
			for (let i = 2; i < face.indices.length; ++i) {
				const a = cell.vertices[face.indices[0]];
				const b = cell.vertices[face.indices[i-1]];
				const c = cell.vertices[face.indices[i]];
				isect(a,b,c, cell,fi);
			}
		}
	}

	//also check grid (at z = 0) [but only if not over a face]:
	if (MOUSE.over === null) {
		const ofs = ray.origin[2];
		const step = ray.direction[2];
		if ((ofs < 0 && step > 0) || (ofs > 0 && step < 0)) {
			const t = -ofs / step;
			if (t < close) {
				close = t;
				MOUSE.over = null;
				MOUSE.grid = {
					x:ray.origin[0] + ray.direction[0] * t,
					y:ray.origin[1] + ray.direction[1] * t,
					z:ray.origin[2] + ray.direction[2] * t
				};
			}
		}
	}

}

//mouse in elt-is-[-1,1]x[-1,1] space:
function relativeMouse(evt, elt) {
	//based on: https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event
	const rect = elt.getBoundingClientRect();
	return {
		x:2.0 * (evt.clientX - rect.left) / rect.width - 1.0,
		y:-2.0 * (evt.clientY - rect.top) / rect.height + 1.0
	};
}

canvas.addEventListener('wheel', function(evt){
	evt.preventDefault();
	let amt = evt.deltaY;
	if (evt.deltaMode === 0x01) amt *= 16.0;
	const zoom = Math.pow(0.5, -0.003 * amt);
	camera.radius *= zoom;
	if (camera.radius < 1.0) camera.radius = 1.0;
	if (camera.radius > 1000.0) camera.radius = 1000.0;
	requestRedraw();
});

canvas.addEventListener('mousedown', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mousedown) ACTION.mousedown(evt, mouse);
	} else {
		if (evt.button == 0) {
			startCameraMove();
		}
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	mouseDirty();
	evt.preventDefault();
});

canvas.addEventListener('mousemove', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mousemove) ACTION.mousemove(evt, mouse);
	} else {
		//generally, nothing
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	mouseDirty();
	evt.preventDefault();
});

canvas.addEventListener('mouseup', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mouseup) ACTION.mouseup(evt, mouse);
	} else {
		//generally, nothing
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	mouseDirty();
	evt.preventDefault();
});

window.addEventListener('keydown', function(evt){
	if (ACTION) {
		if (ACTION.keydown) ACTION.keydown(evt);
	} else {
		if (evt.code === 'Space') {
			body.relax();
			bodyDirty();
		} else if (evt.code == 'KeyA') {
			addCell();
		} else if (evt.code == 'KeyX') {
			deleteCell();
		} else if (evt.code == 'KeyG') {
			startGrabCell(); //start drag
		} else if (evt.code == 'KeyC') {
			startConnectFace(); //start connection
		} else if (evt.code == 'ArrowUp') {
			prevTemplate();
			requestRedraw();
		} else if (evt.code == 'ArrowDown') {
			nextTemplate();
			requestRedraw();
		}
		//console.log(evt.code); //when you want more keys
	}
});

// TODO: Consider moving each script into its own module for the sake of code
// clarity. 

// Solid knitting interface code. 

//select next template from library:
// (uses global 'library' and 'template' variables)
function nextTemplate() {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with larger signature than current:
		if (template !== null && t.signature() <= template.signature()) continue;
		//of these, select the smallest:
		if (selected !== null && selected.signature() < t.signature()) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	template = selected;
}

//select previous template from library:
// (uses global 'library' and 'template' variables)
function prevTemplate() {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with smaller signature than current:
		if (template !== null && t.signature() >= template.signature()) continue;
		//of these, select the largest:
		if (selected !== null && selected.signature() > t.signature()) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	template = selected;
}

//return a cell built as if by pressing 'addCell' at this very location:
// (or 'null' if that wouldn't happen)
function previewCell() {
	//can't add a cell if current template is no template:
	if (template === null) return null;

	if (MOUSE.grid !== null) {
		//transform that puts center of cell at mouse position on the grid:
		const xform = gm.mat4x3(
			1,0,0,
			0,1,0,
			0,0,1,
			MOUSE.grid.x, MOUSE.grid.y, 0
		);
		return sv.Cell.fromTemplate(template, xform);
	}

	if (MOUSE.over !== null) {
		const cell = MOUSE.over.cell;
		const face = MOUSE.over.face; 

		// Only connect if hovered face is not connected. 
		if (!cell.connections[face]) {

			// find face on template with compatible type:
			function compatible(a,b) {
				if (a[0] === '-' && b[0] === '+') return a.substr(1) === b.substr(1);
				if (a[0] === '+' && b[0] === '-') return a.substr(1) === b.substr(1);
				return false;
			}
			let compat = [];
			for (let f = 0; f < template.faces.length; ++f) {
				if (compatible(cell.template.faces[face].type, template.faces[f].type)) {
					compat.push(f);
				}
			}
			if (!compat.length) {
				//console.log(" (no compatible faces)");
			} else {
				const tf = compat[0];

				console.assert(cell.template.faces[face].indices.length === template.faces[tf].indices.length, "Cell and connecting template face have same count of vertices.");

				//vertex lists that should connect:
				const cellVerts = [];
				const templateVerts = [];
				const L = cell.template.faces[face].indices.length;
				for (let i = 0; i < L; ++i) {
					const cv = cell.template.faces[face].indices[i];
					const tv = template.faces[tf].indices[(L+1-i)%L];
					cellVerts.push(cell.vertices[cv]);
					templateVerts.push(template.vertices[tv]);
				}

				const xform = gm.rigidTransform(templateVerts, cellVerts);

				const preview = sv.Cell.fromTemplate(template, xform);

				//record the fact that the connection exists:
				preview.connections[tf] = {cell:cell, face:face};

				return preview;
			}
		}

	}

	return null;
}
window.previewCell = previewCell; //DEBUG

/**
 * addCell (): 
 * Adds cell adjacent to selected face. */
function addCell() {
	if (MOUSE.dirty) setMouseOver();

	//is there a cell that could exist here? Ask the preview function:
	const preview = previewCell();

	//if doesn't exist, don't create anything:
	if (preview === null) return;

	//if the cell *does* exist, hook up the other side of any connections it has:
	for (let f = 0; f < preview.connections.length; ++f) {
		const con = preview.connections[f];
		if (con === null) continue;
		console.assert(con.cell.connections[con.face] === null, "Shouldn't be over-writing connections.");
		con.cell.connections[con.face] = {cell:preview, face:f};
	}

	body.cells.push(preview);

	//update UI and redraw:
	mouseDirty();
	bodyDirty();
}


/**
 * deleteCell (): 
 * Deletes currently selected cell, regardless of face type. 
 * Consider: When cell is selected to delete a box, instead of highlighting
 * selected face, we should highlight selected cell. */
function deleteCell() {
	if (MOUSE.dirty) setMouseOver();
	if (!MOUSE.over) return;

	const cell = MOUSE.over.cell;

	const cellIndex =  body.cells.indexOf(cell);
	const cellConnections = body.cells[cellIndex].connections;

	// Update all connections referencing current cell.
	for (let i = 0; i < cellConnections.length; i++) {
		if(cellConnections[i] != null){
			const currCell = cellConnections[i].cell;
			const currFace = cellConnections[i].face;
			currCell.connections[currFace] = null;
		}
	}

	// Remove current cell from body. 
	body.cells.splice(cellIndex, 1);

	// Update UI and redraw:
	mouseDirty();
	bodyDirty();
}

/**
 * startConnectFace()
 * Start connecting current face
 */
function startConnectFace() {
	if (ACTION !== null) return;
	if (MOUSE.dirty) setMouseOver();
	if (!MOUSE.over) return;
	const cell = MOUSE.over.cell;
	const face = MOUSE.over.face;

	//is face already connected?
	const oldConnection = cell.connections[face];

	function clearConnection() {
		if (cell.connections[face] !== null) {
			const toCell = cell.connections[face].cell;
			const toFace = cell.connections[face].face;
			console.assert(toCell.connections[toFace] !== null
			 && toCell.connections[toFace].cell === cell
			 && toCell.connections[toFace].face === face, "connections should be reflexive");
			toCell.connections[toFace] = null;
			cell.connections[face] = null;
			bodyDirty();
		}
	}

	clearConnection();

	function setConnection() {
		if (!setConnection.pending) return; //HACK: allow cancelling past end-of-action
		setConnection.pending = false;

		clearConnection();
		if (MOUSE.dirty) setMouseOver();
		if (!MOUSE.over) return;
		const toCell = MOUSE.over.cell;
		if (toCell === cell) return; //can't self-connect
		const toFace = MOUSE.over.face;
		if (toCell.connections[toFace]) return; //can't double-connect

		function compatible(a,b) {
			if (a[0] === '-' && b[0] === '+') return a.substr(1) === b.substr(1);
			if (a[0] === '+' && b[0] === '-') return a.substr(1) === b.substr(1);
			return false;
		}
		if (!compatible(cell.template.faces[face].type, toCell.template.faces[toFace].type)) return;


		//make the connection:
		cell.connections[face] = {cell:toCell, face:toFace};
		toCell.connections[toFace] = {cell:cell, face:face};

		bodyDirty();
	}

	console.log("Starting connect.");

	ACTION = {
		mousedown:(evt,mouse) => {
			if (evt.button === 0) {
				startCameraMove();
			} else if (evt.button === 2) {
				console.log("Cancelling connect.");
				setConnection.pending = false;
				cell.connections[face] = oldConnection;
				if (oldConnection) {
					oldConnection.cell.connections[oldConnection.face] = {cell:cell, face:face};
				}
				bodyDirty();
				ACTION = null;
			}
		},
		//nothing: mouseup:(evt,mouse) => { },
		mousemove:(evt,mouse) => {
			if (!setConnection.pending) {
				setConnection.pending = true;
				window.requestAnimationFrame( setConnection );
			}
		},
		keydown:(evt) => {
			if (evt.code === 'KeyC') {
				console.log("Confirming connect.");
				setConnection.pending = false;
				ACTION = null;
			}
		},
	};


}


/**
 * startGrabCell()
 * Grab (start moving) current cell.
 */
function startGrabCell() {
	if (ACTION !== null) return;

	if (MOUSE.dirty) setMouseOver();

	if (!MOUSE.over) return;


	const cell = MOUSE.over.cell;
	const startXform = cell.xform;
	const startVertices = [];
	let center = gm.vec3(0);
	for (const v of cell.vertices) {
		startVertices.push(gm.vec3(v));
		center = gm.add(center, v);
	}
	center = gm.scale(1 / cell.vertices.length, center);

	const right = camera.computeRight();
	const up = camera.computeUp();
	const out = camera.computeOut();

	function mousePt() {
		const ray = mouseRay();
		const offset = gm.dot(gm.sub(ray.origin, center), out);
		const step = gm.dot(ray.direction, out);
		if (Math.abs(step) < 1e-3 * Math.abs(offset)) return null;
		const t = -offset / step;
		return gm.add(ray.origin, gm.scale(t, ray.direction));
	}

	const begin = mousePt();
	if (begin === null) {
		console.warn("Trying to start drag from null point -- cancelling.");
		return;
	}

	function cancelGrab() {
		console.log("Cancelling grab.");
		cell.vertices = startVertices;
		cell.xform = startXform;
		ACTION = null;
		bodyDirty();
	}

	ACTION = {
		mousedown:(evt,mouse) => {
			if (evt.button == 0) {
				console.log("Confirming grab.");
				ACTION = null;
				bodyDirty();
			} else if (evt.button == 2) {
				cancelGrab();
			}
		},
		//nothing: mouseup:(evt,mouse) => { },
		mousemove:(evt,mouse) => {
			MOUSE.x = mouse.x;
			MOUSE.y = mouse.y;
			const at = mousePt();
			if (at !== null) {
				const delta = gm.sub(at,begin);
				for (let i = 0; i < cell.vertices.length; ++i) {
					cell.vertices[i] = gm.add(startVertices[i], delta);
				}
				cell.xform = gm.rigidTransform(cell.template.vertices, cell.vertices); //could compute directly from starting xform but this is not performace-critical code
				bodyDirty();
			}
		},
		keydown:(evt) => {
			if (evt.code === 'Escape') {
				cancelGrab();
			}
		}
	};
}

/**
 * startCameraMove()
 */
function startCameraMove() {
	let oldACTION = ACTION;
	camFlipX = (camera.computeUp()[2] < 0.0);

	ACTION = {
		//ignore: mousedown:(evt,mouse) => { },
		mouseup:(evt,mouse) => {
			if (evt.button === 0) {
				ACTION = oldACTION;
				return;
			}
		},
		mousemove:(evt,mouse) => {
			if (MOUSE.x !== MOUSE.x) return;
			if (evt.shiftKey) {
				const up = camera.computeUp();
				const right = camera.computeRight();

				const x = camera.radius * (mouse.x - MOUSE.x) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI) * camera.aspect;
				const y = camera.radius * (mouse.y - MOUSE.y) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI);

				camera.target = gm.sub(camera.target, gm.add(gm.scale(x, right), gm.scale(y, up)));
			} else {
				const deltaToAngle = 2.0 * camera.fovy / 180.0 * Math.PI;
				camera.azimuth += (camFlipX ? -1.0 : 1.0) * -(mouse.x - MOUSE.x) * camera.aspect * deltaToAngle;
				camera.elevation -= (mouse.y - MOUSE.y) * deltaToAngle;
			}
			requestRedraw();
		}
	};
}

//--- vector math library ---
//TODO: clean this up and move to its own module

function lookAt(eye, target, up) {
	var out = gm.normalize(gm.sub(eye, target));
	var proj = gm.dot(up, out);
	up = gm.normalize( gm.sub(up, gm.scale(proj, out) ) );

	var right = gm.cross(up, out);

	var offset = gm.vec3(-gm.dot(eye, right), -gm.dot(eye, up), -gm.dot(eye, out));

	return new Float32Array([
		right[0], up[0], out[0], 0.0,
		right[1], up[1], out[1], 0.0,
		right[2], up[2], out[2], 0.0,
		offset[0], offset[1], offset[2], 1.0
	]);
}

function perspective(fovy, aspect, zNear) {
	var f = 1 / Math.tan(fovy/2 * Math.PI / 180.0);
	return new Float32Array([
		f / aspect, 0.0, 0.0, 0.0,
		0.0, f, 0.0, 0.0,
		0.0, 0.0, -1, -1.0,
		0.0, 0.0,-2.0 * zNear, 0.0
	]);
}
function mul(A, B) {
	var out = new Float32Array(16);
	for (var r = 0; r < 4; ++r) {
		for (var c = 0; c < 4; ++c) {
			var val = 0.0;
			for (var k = 0; k < 4; ++k) {
				val += A[k * 4 + r] * B[c * 4 + k];
			}
			out[4 * c + r] = val;
		}
	}
	return out;
}

function computeMVP() {
	/*//DEBUG:
	return new Float32Array([
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0
	]);*/
	const P = perspective(camera.fovy, camera.aspect, 0.1);
	const up = camera.computeUp();
	const MV = lookAt(
		camera.computeAt(),
		camera.target,
		up
	);
	return mul(P, MV);
}

//------- benchmark -------

/*
function benchmark() {
	console.log("Running benchmark....");

	//Okay, how to benchmark renderer? Consistent frame size, camera position, yarns.

	canvas.style.width = "1024px";
	canvas.style.height = "1024px";

	setBenchmarkYarns();

	camera.target = {x:0.0, y:0.0, z:0.0};
	camera.radius = 37;
	camera.azimuth = 0.0;
	camera.elevation = 0.0;
	camera.fovy = 60.0;
	camera.aspect = 1.0;

	let before = performance.now();
	let iters = 0;
	while (iters < 1000) {
		++iters;
		redraw();
		gl.finish();
		let after = performance.now();
		if (after - before > 2000) break;
	}
	let total = performance.now() - before;
	console.log("Did " + iters + " iterations in " + total + "ms.");
	let result = iters.toString() + " iterations, avg " + total/iters + "ms per";
	document.getElementById("benchmark-result").innerText = result;
}

document.getElementById("benchmark").addEventListener('click', benchmark);
*/

//------- rendering -------

//very simple shader program for vertex-colored things:
const colorProgram = new Program(gl,
`
	uniform mat4 LOCAL_TO_CLIP;

	attribute vec4 Position;
	attribute vec3 Normal;
	attribute vec4 Color;

	varying vec4 color;
	varying vec3 normal;

	void main() {
		gl_Position = LOCAL_TO_CLIP * Position;
		color = Color;
		normal = Normal;
	}
`,`
	uniform highp vec3 HEMI_DIRECTION;
	uniform lowp vec4 TINT;
	varying lowp vec4 color;
	varying highp vec3 normal;
	void main() {
		highp vec3 n = normalize(normal);
		//upper dome light:
		highp vec3 light = mix(vec3(0.1), vec3(1.0), 0.5*dot(n, HEMI_DIRECTION)+0.5);
		gl_FragColor = TINT * vec4(color.rgb * light, color.a);
	}
`);
window.colorProgram = colorProgram; //DEBUG


//when using a data view to store Float32 values, do they need to be marked as little endian?
const FLOAT32_LITTLE_ENDIAN = function() {
	let array = new ArrayBuffer(4);
	let f32 = new Float32Array(array);
	let data = new DataView(array);
	f32[0] = 1.0;
	if (data.getFloat32(0, false) === f32[0]) {
		assert(data.getFloat32(0, true) !== f32[0]);
		return false;
	} else if (data.getFloat32(0, true) === f32[0]) {
		assert(data.getFloat32(0, false) !== f32[0]);
		return true;
	}
};

class Grid extends Geometry {
	constructor() {
		const BYTES_PER_ATTRIB = 4*2 + 1*4;
		const RADIUS = 10;

		const arrayBuffer = new ArrayBuffer(4*(2*RADIUS+1+1) * BYTES_PER_ATTRIB);
		const data = new DataView(arrayBuffer);

		let dataOffset = 0;

		function attrib(x,y, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		/*
		//TODO: maybe eventually have axis at origin
		//axes:
		line({x:0,y:0,z:0},{x:5,y:0,z:0}, 0xff0000ff);
		line({x:0,y:0,z:0},{x:0,y:5,z:0}, 0x00ff00ff);
		line({x:0,y:0,z:0},{x:0,y:0,z:5}, 0x0000ffff);
		*/


		for (let x = -RADIUS; x <= RADIUS; ++x) {
			if (x === 0) {
				attrib(x,-RADIUS, 0x008800ff);
				attrib(x, 0, 0x008800ff);
				attrib(x, 0, 0x88ff88ff);
				attrib(x, RADIUS, 0x88ff88ff);
			} else {
				const col = (x == 0 ? 0x88ff88ff : 0x888888ff);
				attrib(x,-RADIUS, 0x888888ff);
				attrib(x, RADIUS, 0x888888ff);
			}
		}
		for (let y = -RADIUS; y <= RADIUS; ++y) {
			if (y === 0) {
				attrib(-RADIUS,y, 0x880000ff);
				attrib( 0,y, 0x880000ff);
				attrib( 0,y, 0xff8888ff);
				attrib( RADIUS,y, 0xff8888ff);
			} else {
				attrib(-RADIUS,y, 0x888888ff);
				attrib( RADIUS,y, 0x888888ff);
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		const buffer = gl.createBuffer();
		const count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);

		const attribs = {
			Position:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*2},
			Normal:[0.0, 0.0, 1.0]
		};

		super(gl, attribs, gl.LINES, count);
	}
}
const grid = new Grid();
window.grid = grid; //DEBUG

//helper for color conversion from '#rrggbb', '#rrggbbaa', '#rgb', and '#rgba' to 0xrrggbbaa
function css2Uint32(color) {
	let val;
	if        (color.length === 9) {
		val = parseInt('0x' + color.substr(1));
	} else if (color.length === 7) {
		val = parseInt('0x' + color.substr(1)) * 256 + 255;
	} else if (color.length === 5) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		const a = (val & 0x000f);
		//why are these not bit-shifts? because those coerce numbers to *signed* int32s integers (vs remaining float64's, which have 50-ish bits of integer precision)
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + (a * 16 + a);
	} else if (color.length === 4) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + 255;
	}
	return val;
}

function rgb2Uint32(color) {
	let val;
	val = Math.max(0, Math.min(255, Math.round(255 * color[0])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[1])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[2])));
	val = val * 256 + 255;
	return val;
}


class VisBody extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 4*3 + 1*4; //Position, Normal, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3},
		};

		super(gl, attribs, gl.TRIANGLES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(blocks) {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				totalAttribs += 3 * (face.indices.length - 2);
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, nx,ny,nz, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, nx, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, ny, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, nz, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}
		
		function triangle(va,vb,vc, color) {
			let n = gm.normalize(gm.cross(gm.sub(vb, va), gm.sub(vc, va)));
			attrib(va[0],va[1],va[2], n[0],n[1],n[2], color);
			attrib(vb[0],vb[1],vb[2], n[0],n[1],n[2], color);
			attrib(vc[0],vc[1],vc[2], n[0],n[1],n[2], color);
		}
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				//TODO: compute normals in some smooth way
				for (let i = 2; i < face.indices.length; ++i) {
					triangle(
						cell.vertices[face.indices[0]], cell.vertices[face.indices[i-1]], cell.vertices[face.indices[i]],
						css2Uint32(face.color));
					
				}
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}
const visBody = new VisBody();
window.visBody = visBody; //DEBUG

class VisWire extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisWire.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(blocks) {
		const BYTES_PER_ATTRIB = VisWire.BYTES_PER_ATTRIB;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				totalAttribs += face.indices.length * 2 + 4;
				const con = cell.connections[fi];
				if (con !== null) totalAttribs += face.indices.length * 3;
			}
			for (const yarn of cell.template.yarns) {
				totalAttribs += (yarn.pts.length-1)*2;
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		for (const cell of body.cells) {
			let ports = [];
			
			{ //compute cell center:
				let center = gm.vec3(0.0);
				for (let v of cell.vertices) {
					center = gm.add(center, v);
				}
				center = gm.scale(1.0 / cell.vertices.length, center);
				cell.center = center;
			}

			if (!('vertexColors' in cell.template)) {
				cell.template.vertexColors = [];
				for (let i = 0; i < cell.template.vertices.length; ++i) {
					while (true) {
						let r = Math.random();
						let g = Math.random();
						let b = Math.random();
						let min = Math.min(r,g,b);
						let max = Math.max(r,g,b);
						if (max - min < 1e-3) continue;
						r = (r - min) / (max - min);
						g = (g - min) / (max - min);
						b = (b - min) / (max - min);
						cell.template.vertexColors.push(gm.vec3(r,g,b));
						break;
					}
				}
			}

			//yarns:
			const xf = cell.xform;
			for (const yarn of cell.template.yarns) {
				let prev = null;
				let col = rgb2Uint32([1.0, 0.6, 0.5]);
				for (const pt of yarn.pts) {
					let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
					if (prev !== null) {
						attrib(prev[0],prev[1],prev[2], col);
						attrib(at[0],at[1],at[2], col);
					}
					prev = at;
				}
			}

			for (const face of cell.template.faces) {
				let center = gm.vec3(0.0);
				for (let vi of face.indices) {
					center = gm.add(center, cell.vertices[vi]);
				}
				center = gm.scale(1.0 / face.indices.length, center);
				let port = [];
				for (let i = 0; i < face.indices.length; ++i) {
					let v = cell.vertices[face.indices[i]];
					v = gm.mix(v, center, 0.5); //move toward center of face
					port.push(v);
				}
				ports.push(port);
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32(face.color);
					attrib(a[0],a[1],a[2], col);
					attrib(b[0],b[1],b[2], col);
					if (i === 0) {
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						col = 0xffff00ff; //highlight "first edge"
						attrib(a[0],a[1],a[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(b[0],b[1],b[2], col);
					}
				}
			}
			cell.ports = ports;
		}

		//connections:
		for (const cell of body.cells) {
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) continue;
				if (cell.template.faces[fi].type[0] !== '+') continue; //draw connectsions from '+' => '-'

				for (let i = 0; i < cell.ports[fi].length; ++i) {
					let ci = (cell.template.faces[fi].indices.length + 1 - i) % cell.template.faces[fi].indices.length;
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attrib(ca[0], ca[1], ca[2], 0x888888ff); attrib(a[0], a[1], a[2], 0x888888ff);
					attrib(a[0], a[1], a[2], 0x888888ff); attrib(b[0], b[1], b[2], 0xffffffff);
					attrib(b[0], b[1], b[2], 0xffffffff); attrib(cb[0], cb[1], cb[2], 0xffffffff);
				}
			}
		}

		//remove temp stuff:
		for (const cell of body.cells) {
			delete cell.center;
			delete cell.ports;
		}


		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}

const visWire = new VisWire();
window.visWire = visWire; //DEBUG

class VisDebug extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisDebug.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer;
	}
	update() {
		const BYTES_PER_ATTRIB = VisDebug.BYTES_PER_ATTRIB;

		let attribs = []; //x,y,z,color

		function line(a,b,color) {
			attribs.push(a[0],a[1],a[2],color);
			attribs.push(b[0],b[1],b[2],color);
		}

		//----- make debug lines ----
		
		//mouse cursor:
		if (MOUSE.x === MOUSE.x) {
			const ray = mouseRay();
			let r = camera.computeRight();
			let u = camera.computeUp();
			r = gm.scale(0.01, r);
			u = gm.scale(0.01, u);
			const c = gm.add(ray.origin, ray.direction);
			line(gm.add(c,r), gm.sub(c,r), 0xffff00ff);
			line(gm.add(c,u), gm.sub(c,u), 0xffff00ff);
		}

		//currently hovered face:
		if (MOUSE.over !== null) {
			const cell = MOUSE.over.cell;
			const face = cell.template.faces[MOUSE.over.face];
			for (let i = 0; i < face.indices.length; ++i) {
				line(cell.vertices[face.indices[(i == 0 ? face.indices.length : i) - 1]], cell.vertices[face.indices[i]], 0xffff0088);
			}
		}

		//currently hovered grid cell:
		if (MOUSE.grid !== null) {
			const x = Math.floor(MOUSE.grid.x);
			const y = Math.floor(MOUSE.grid.y);

			line([x, y, 0], [x+1,y,0], 0xff00ffff);
			line([x+1,y, 0], [x+1,y+1,0], 0xff00ffff);
			line([x+1, y+1, 0], [x,y+1,0], 0xff00ffff);
			line([x,y+1,0], [x,y,0], 0xff00ffff);
		}

		const cell = previewCell();
		if (cell !== null) { //preview cell addition:
			for (let face of cell.template.faces) {
				for (let i = 0; i < face.indices.length; ++i) {
					line(cell.vertices[face.indices[i]], cell.vertices[face.indices[(i+1)%face.indices.length]], 0x888800ff);
				}
			}
			//yarns:
			const xf = cell.xform;
			for (let yarn of cell.template.yarns) {
				for (let i = 1; i < yarn.pts.length; ++i) {
					line(gm.mul_mat4x3_vec4(xf, [...yarn.pts[i-1],1]), gm.mul_mat4x3_vec4(xf, [...yarn.pts[i],1]), 0xffffffff);
				}
			}
		}

		//---- copy debug lines to buffer for drawing ----

		//copy attribs to a formatted buffer:
		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * (attribs.length / 4));
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		for (let i = 0; i < attribs.length; i += 4) {
			data.setFloat32(dataOffset, attribs[i+0], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+1], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+2], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, attribs[i+3], false); dataOffset += 4;
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STREAM_DRAW);
	}
}
const visDebug = new VisDebug();

function redraw() {
	const pixelRatio = window.devicePixelRatio;

	//make sure canvas size matches element size:
	(function resize() {
		const style = getComputedStyle(canvas);
		window.style = style;

		const width = Math.round(parseFloat(style.width) * pixelRatio);
		const height = Math.round(parseFloat(style.height) * pixelRatio);
		canvas.width = width;
		canvas.height = height;
		gl.viewport(0,0,width,height);
		camera.aspect = width / height;
	})();

	//update mouse info:
	if (MOUSE.dirty) setMouseOver();

	//update geometry:
	if (visWire.dirty) {
		visWire.set(body);
		delete visWire.dirty;
	}
	if (visBody.dirty) {
		visBody.set(body);
		delete visWire.dirty;
	}

	visDebug.update();

	gl.clearColor(0.1, 0.1, 0.1, 1.0);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	gl.useProgram(colorProgram.program);

	gl.uniformMatrix4fv(
		colorProgram.uniformLocations.LOCAL_TO_CLIP,
		false,
		computeMVP()
	);

	const lightDir = gm.normalize(gm.add(camera.computeUp(),camera.computeOut()));
	gl.uniform3f(
		colorProgram.uniformLocations.HEMI_DIRECTION,
		lightDir[0], lightDir[1], lightDir[2]
	);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		1.0, 1.0, 1.0, 1.0
	);


	gl.lineWidth(2.0 * pixelRatio);
	visDebug.draw(colorProgram);

	gl.lineWidth(1.0 * pixelRatio);
	grid.draw(colorProgram);

	//visBody.draw(colorProgram);
	visWire.draw(colorProgram);

	//show "hidden" debug lines also:

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		0.0, 0.0, 0.0, 0.1
	);
	gl.depthFunc(gl.GREATER);
	gl.depthMask(false);
	gl.lineWidth(2.0 * pixelRatio);
	visDebug.draw(colorProgram);

	gl.depthFunc(gl.LESS);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
}

function requestRedraw() {
	if (requestRedraw.requested) return;
	requestRedraw.requested = true;
	window.requestAnimationFrame(function(ts){
		delete requestRedraw.requested;
		redraw();
	});
}
window.requestRedraw = requestRedraw;

resetCamera();
requestRedraw();

window.addEventListener('resize', requestRedraw);

async function init() {
	{
		console.log(`Fetching library...`);
		//const request = await fetch('solid-knitting.library');
		const request = await fetch('block-library/blocks.json');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.library = sv.Library.fromArrayBuffer(arrayBuffer);
		//hack-y way of selecting first template:
		window.template = null;
		nextTemplate();

		let info = 'Library contains:';
		for (let name of Object.keys(library.templates).sort()) {
			info += '\n   ' + name;
		}
		console.log(info);
	}

	{
		console.log(`Fetching body...`);
		const request = await fetch('cube-3x3.body');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.body = sv.Body.fromArrayBuffer(arrayBuffer, library);
	}

	bodyDirty();
	resetCamera();
	requestRedraw();
}

init();

</script>
</body>
</html>
