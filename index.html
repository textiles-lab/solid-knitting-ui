<!DOCTYPE html>
<html>
<head>
<title>Solid Knitting UI</title>
<style>

body.darkmode {
	--far-background-color: #333230;
	--background-color: #232220;
	--background-color-medium: #232220bb;
	--background-color-light: #23222066;
	--background-color-highlight: #dde1;
	--separator-color: #434240;
	--main-font-color: #C4C0AD;
	--far-font-color: #E4E0CD;
	--font-color-highlight: #D4D0CD;

	/* syntax highlighting */
	--comment: #74705D;
	--location: #A6E42C;
	--direction: #AC7DFF;
	--keyword: #FF2275;
	--carrier: #EEEEEE;
	--string: #EDE277;
}

body.lightmode {
	--far-background-color: #d4ccd2;
	--background-color: #f6f0ee;
	--background-color-medium: #f6f0eebb;
	--background-color-light: #f6f0ee66;
	--background-color-highlight: #2221;
	--separator-color: #c4bcc2;
	--main-font-color: #222;
	--far-font-color: #111;
	--font-color-highlight: #222;

	/* syntax highlighting, from solarized https://en.wikipedia.org/wiki/Solarized */
	--comment: #839496;
	--location: #2aa198;
	--direction: #268bd2;
	--keyword: #cb4b16;
	--carrier: #073642;
	--string: #b58900;
}

body {
	padding:0;
	margin:0;

	background-color: var(--far-background-color);
	color: var(--far-font-color);
}

#dropTarget {
	position:fixed;
	left:0;
	bottom:0;
	width:100%;
	height:100%;

	background:#ccc;
	outline:4px dashed #eee;
	outline-offset:-20px;
	z-index:100;
	visibility:hidden;
}
#dropTarget.active {
	visibility:visible;
	background:#eee;
	outline-color:#ccc;
}
#file {
	display:none;
}

#views {
	display:grid;
/*	width:99vw;*/
	height:99vh;

	grid-template-columns: 1fr auto ;
	grid-template-rows: auto 1.0fr;
	overflow: none;
	grid-gap: 5px;

	/*background: #0008 ;*/
}
#controls {
	grid-column: 1 / 3 ;
	grid-row: 1 ;
	gap: 8px;
	font-size: 16px;
	line-height:16px;
	padding: 5px 5px;
	display:flex;
	flex-flow: row wrap;
	align-items: center;
	/*background: #f008 ;*/
}

.controlsButton {
	box-sizing:border-box;
	cursor:pointer;
	display:inline-block;
	background:#cfbb96;
	padding:4px 8px;
	margin:0;
	box-shadow: 0 1px 2px 0 #0008;
	text-decoration:none;
	line-height:1;
	border: none;
	border-radius:2px;
/*	height:100%;*/
	font-size:inherit;
	font-family: sans-serif;
	color: black;
}

.controlsButton:hover {
	background:#f6d69b;
}

.controlsButton:active {
	box-shadow: 0 0 1px 0 #0008;
}

.controls-section {
	margin-left: 1em;
}

#view-3d {
	grid-column: 1 ;
	grid-row: 2 ;
	/*background: #0f08 ;*/
	display: grid;
	grid-template-rows: auto 1fr;
	grid-template-columns: 1fr;

	color: var(--main-font-color);
}
#canvas-wrapper {
	position:relative;
	overflow: hidden;
	background-color: var(--background-color);
	border-top: solid 2pt var(--separator-color);
	border-radius: 0 5px 5px 0;
}
#canvas {
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
	background-color: var(--background-color);
}
#status-line {
	position:absolute;
	left:0;
	bottom:0;
	background:#fff8;
	color: black;
	padding: 0.15em 0.3em;
}
#darkmode-checkbox {
	width: 0;
	height: 0;
	visibility: hidden;
}

body.darkmode #darkmode-checkbox-label::after {
	content: "\263C";
}
body.lightmode #darkmode-checkbox-label::after {
	content: "\263D";
}

#render-options {
	padding: 0 0.5em;
	position: absolute;
	top: 0;
	left: 0;
	background: var(--background-color-medium);

}
#render-options > summary {
	cursor:pointer;
	font-size: 2em;
	list-style: none;
}
#render-options > summary:hover {
	color: var(--font-color-highlight);
}
#render-options > summary::-webkit-details-marker { /* hide details triangle https://stackoverflow.com/a/56649741 */
 	display: none;
}

#sidebar {
	grid-column: 2 ;
	grid-row: 2 ;

	display:grid;
	grid-template-rows: min-content 1fr min-content;
	grid-gap: 5px;

	width: 24em;
	min-height: 0; /* don't expand past parent height https://stackoverflow.com/a/43312314 */
/*	background: #00f8 ;*/

	color: var(--main-font-color);
	background-color: var(--far-background-color);
}
.tab-menu-container {
	margin: 0;
	margin-left: 0.25em;
	padding: 0;
	display: grid;
	box-sizing: border-box;
	grid-template-columns: auto 1fr auto;
	grid-template-rows: auto;

	align-items: center; /* center-align text in menu items */
	background-color: var(--far-background-color);
	color: var(--far-font-color);
}

.tab-menu span {
	padding: 0.25em 0.5em;
}

.tab-menu {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: repeat(8, max-content);
	grid-gap: 1pt;
}
.tab-menu input[type=radio] { /* invisible radio button to save state https://stackoverflow.com/a/8037883 */
	visibility: hidden;
	width: 0;
	height: 0;
	margin: 0;
	padding: 0;
}
.tab-menu label {
	border: 0;
	font-family: sans-serif;
	border-radius: 0.25em 0.25em 0 0;
	padding: 0.5em 1em 0.25em 1em;
	border: solid 2pt var(--separator-color);
	border-bottom-style: none;
	cursor: pointer;
	background-color: var(--background-color-light);
}
.tab-menu label:hover {
	background-color: var(--background-color-medium);
}
.tab-menu label.active {
	background-color: var(--background-color);
	border-bottom: solid 2pt var(--background-color);
	margin-bottom: -2pt;
	z-index: 1;
}
#sidebar h2, #sidebar summary {
	font-size:20px;
	font-weight: bold;
	line-height:20px;
	padding: 0;
	margin: 0;
	margin-bottom: 0.5em;
	font-family: sans-serif;
}
#library {
/*	grid-row: 2 ;*/
	margin:0;
	padding: 0.5em 0 0 0.5em; /* top right bottom left */
	min-height: 0;
	display:grid; /* set to grid from javascript later too */
	grid-template-rows: auto 1fr;
	padding-bottom: 0.5em;
/*	border-left: 2pt solid var(--separator-color);*/
	border-radius: 5px 0 0 5px;
	background-color: var(--background-color);
	margin-top: -5px;
	border-top: solid 2pt var(--separator-color);
}
#library-list {
/*	grid-row: 2 ;*/
	margin:0;
	padding:0;
	min-width: 0;
	min-height: 0;
	overflow-y: scroll;
}
#library ul {
	list-style:none;
}
#library li {
	display:block;
	margin:0em 0.15em;
	padding:0.15em 0.5em;
	border-radius:0.2em;
	cursor:pointer;
	border: 1pt solid var(--background-color);
}
#library li:hover {
	background-color: var(--background-color-highlight);
	color: var(--font-color-highlight);
}
#library .library-active-template {
	background-color: var(--background-color-highlight);
	color: var(--font-color-highlight);
	border: 1pt solid var(--separator-color);
}
#view-shortcuts {
	/*border-top: 2px solid var(--separator-color);
	border-left: 2pt solid var(--separator-color);*/
	padding-left: 0.25em;
	padding-top: 0.5em;
	border-radius: 5px;
	background-color: var(--background-color);
}
#shortcuts {
	grid-row: 3 ;
	margin:0;
	padding:0;
}
#shortcuts li {
	display:block;
	margin:0.1em 0.15em;
	padding:0.0em 0.5em;
}
#shortcuts .key {
	font-family: monospace;
}
#view-knitout {
	margin: 0;
	padding: 0;
	overflow: auto;
	display:grid; /* set to grid from javascript later too */
	grid-template-rows: 1fr auto;
/*	border-left: 2pt solid var(--separator-color);*/
	border-radius: 5px 0 0 5px;
	background-color: var(--background-color);
	margin-top: -5px;
	border-top: solid 2pt var(--separator-color);
}
#view-knitout #view-knitout-options {
	padding: 0.5em 1em;
	background-color: var(--background-color);
}
#knitout-source {
	font-family: monospace;
	padding-top: 0.5em;
	min-height: 0;
	overflow-y: scroll;
	margin-bottom: 0.5em;
/*	background-color: #272822;*/
}
/* code styling */
#knitout-source span {
	/* position: relative; /* for tooltips */
	white-space: pre; /* preserve whitespace */
}

/* https://www.w3schools.com/css/css_tooltip.asp */
/*#knitout-source span .tooltiptext {
	visibility: hidden;
	position: absolute;
	z-index: 1;
	background-color: #202010;
	padding: 0.5em 1em;
	color: white;
	top: 0;
	left: 4em;
	border: 1pt solid #555;
	border-radius: 0.25em;
}
#knitout-source span:hover .tooltiptext {
	visibility: visible;
}*/
#knitout-source .line {
	padding: 0 0;
	display: flex;
}
#knitout-source .line-number {
	color: #94908D;
	width: 2em;
	padding: 0 0.5em;
	display: inline-block;

	/* disable selection: https://stackoverflow.com/a/4407335 */
	-webkit-touch-callout: none; /* iOS Safari */
	-webkit-user-select: none; /* Safari */
	 -khtml-user-select: none; /* Konqueror HTML */
	   -moz-user-select: none; /* Old versions of Firefox */
	    -ms-user-select: none; /* Internet Explorer/Edge */
	        user-select: none; /* Non-prefixed version, currently
	                              supported by Chrome, Edge, Opera and Firefox */
}
#knitout-source .line:hover {
	color: #C4C0BD;
	background-color: var(--background-color-highlight);
}
#knitout-source .code {
	border-left: 2px solid var(--separator-color);
/*	box-shadow: inset 8px 0 8px -10px black;*/
	padding-left: 0.5em;
	width: 100%;
}
#knitout-source .comment {
	color: var(--comment);
}
#knitout-source .location {
	color: var(--location);
}
#knitout-source .direction {
	color: var(--direction);
}
#knitout-source .keyword {
	color: var(--keyword);
}
#knitout-source .carrier {
	color: var(--carrier);
}
#knitout-source .string {
	color: var(--string);
}

#view-block-data {
	display: grid; /* set to grid from javascript later too */
	grid-template-rows: auto 1fr;
	gap: 0;
	padding-bottom: 0.5em;
	/*border-top: 2pt solid var(--separator-color);
	border-left: 2pt solid var(--separator-color);*/
	border-radius: 5px 0 0 5px;
	background-color: var(--background-color);
}
#view-block-data h2 {
	padding: 0.5em 0 0 0.5em; /* top right bottom left */
}
#hovered-block-info {
	display: grid;
	grid-template-columns: auto 1fr;
	grid-template-rows: max-content;
	align-content: start;
	gap: 0;
	align-items: stretch;
}
/* shade every other row https://stackoverflow.com/a/44937583 */
#hovered-block-info > :nth-child(4n+1), #hovered-block-info > :nth-child(4n+2) {
	background-color: var(--background-color-highlight);
}
#hovered-block-info .field-name {
	padding: 0.15em 0.25em 0.15em 0.5em; /* top right bottom left */
	min-height: 0;
	display: inline-flex;
	align-items: center;         /* vertically-center text */
	justify-content: flex-end;   /* align right */
}
#hovered-block-info .field-name:after {
	content: ":";
}
#hovered-block-info .field-value {
	padding: 0.25em 1em 0.25em 0.5em; /* top right bottom left */
	font-family: monospace;
}
#hovered-block-info input[type=text] {
	font-family: monospace;
	width: 100%;
	border: none;
	background-color: #fff1;
	color: var(--main-font-color);
	border-radius: 2pt;
	border: 1pt var(--separator-color) solid;
}
</style>
</head>
<body class="lightmode">

<div id="views">

<!-- controls bar at the top of the window -->
<div id="controls">
<input id="file" type="file" />
<label id="fileLabel" for="file" class="controlsButton">Load</label>
<!-- <button id="benchmark">benchmark</button>
<span id="benchmark-result"></span> -->
<button id="save" class="controlsButton">Save</button>

<button id="export" class="controlsButton">Export Solid Knitout</button>
<button id="save-yarn-path" class="controlsButton">Save Yarn Path</button>
<button id="save-knitout" class="controlsButton">Save Knitout</button>
<button id="reallocate-spots" class="controlsButton">Reallocate Needle Locations</button>

</div>

<!-- 3d view -->
<div id="view-3d">
	<div id="viewmode-options" class="tab-menu-container">
		<span id="fileName">(no file loaded)</span>
		<form id="select-3dview-mode" class="tab-menu">
			<input type="radio" name="3dview-mode" id="3dview-pattern-mode" value="Pattern" checked><label id="3dview-set-pattern-mode" for="3dview-pattern-mode" class="tab">Pattern</label><input type="radio" name="3dview-mode" id="3dview-template-mode" value="Template" class="tab"><label id="3dview-set-template-mode" for="3dview-template-mode">Templates</label>
		</form>
		<form id="darkmode-toggle">
			<input type="checkbox" id="darkmode-checkbox" name="darkmode" value="darkmode" checked><label for="darkmode-checkbox" id="darkmode-checkbox-label"></label>
		</form>
	</div>
	<div id="canvas-wrapper">
		<canvas id="canvas" width="120" height="120"></canvas>
		<div id="status-line">(Status Line)</div>
		<details id="render-options">
			<summary>&#9881;</summary>
			<div id="yarn-vis-options" class="controls-section">
				Yarn Visualization:
				<select id="select-yarn-vis-option">
					<option value="Tube" selected>Tube</option>
					<option value="Wire">Wire</option>
					<option value="Body">Body</option>
				</select>
			</div>
			<div id="layer-visibility-options" class="controls-section">
				Layer Visibility:
				<form id="layer-visibility-form" style="display:inline-block;">
					<input type="checkbox" name="layer-visible" value="0" checked>0
					<input type="checkbox" name="layer-visible" value="1" checked>1
					<input type="checkbox" name="layer-visible" value="2" checked>2
					<input type="checkbox" name="layer-visible" value="3" checked>3
					<input type="checkbox" name="layer-visible" value="4" checked>4
				</form>
			</div>
			<div id="yarn-direction-vis-options" class="controls-section">
				<form id="show-yarn-direction-form" style="display:inline-block;">
					<input type="checkbox" name="show-yarn-direction" value="0"> Show Yarn Direction
				</form>
			</div>
		</details>
	</div>
</div>

<!-- library panel -->
<div id="sidebar">
<div id="sidebar-menu" class="tab-menu-container">
	<form id="select-sidebar-mode" class="tab-menu">
		<input type="radio" name="sidebar-mode" id="sidebar-design-mode" value="PatternDesign" checked><label id="sidebar-set-design-mode" for="sidebar-design-mode" class="tab">Pattern Design</label><input type="radio" name="sidebar-mode" id="sidebar-codegen-mode" value="CodeGen"><label id="sidebar-set-codegen-mode" for="sidebar-codegen-mode" class="tab">Code Generation</label>
	</form>
</div>
<div id="library">
<h2>Block Library:</h2>
<ul id="library-list">
</ul>
</div>

<!-- preview generated knitout -->
<div id="view-knitout">
	<div id="view-knitout-options">
		<form id="group-knitout-passes-form" style="display:inline-block;">
		<label for="group-knitout-passes">Group knitout passes:</label>
		<input type="checkbox" name="group-knitout-passes">
		</form>
	</div>
	<div id="knitout-source"></div>
</div>

<!-- see information about highlighted block -->
<div id="view-block-data">
	<h2> Block Info:</h2>
	<form id="hovered-block-info"></form>
</div>

<!-- also list shortcuts -->
<details id="view-shortcuts" open>
<summary>Commands:</summary>
<ul id="shortcuts">
	<li> <button class="controlsButton" id="relax-shape">Relax shape</button> (<span class="key">space</span> or <span class="key">R</span>)</li>
	<li> <button class="controlsButton" id="select-hovered-template">Select hovered template</button> (<span class="key">enter</span>)</li>
	<li> <button class="controlsButton" id="delete">Delete cell</button> (<span class="key">X</span>)</li>
	<li> <button class="controlsButton" id="grab">Grab cell</button> (<span class="key">G</span>)</li>
	<li> <button class="controlsButton" id="start-connection">Start/make connection</button> (<span class="key">C</span>)</li>
	<li> <button class="controlsButton" id="check-for-cycles">Check for cycles</button> (<span class="key">U</span>)</li>
	<li> <button class="controlsButton" id="prev-template">Prev template</button> (<span class="key">up</span>)</li>
	<li> <button class="controlsButton" id="next-template">Next template</button> (<span class="key">down</span>)</li>
	<li> <button class="controlsButton" id="prev-compatible-template">Prev compatible template</button> (<span class="key">K</span>)</li>
	<li> <button class="controlsButton" id="next-compatible-template">Next compatible template</button> (<span class="key">J</span>)</li>
	<li> <button class="controlsButton" id="select-hovered-block">Select hovered block</button> (<span class="key">S</span>)</li>
	<li> <button class="controlsButton" id="undo">Undo</button> (<span class="key">ctrl-Z</span>)</li>
	<li> <button class="controlsButton" id="escape-from-action">Escape from grab/connect/selection</button> (<span class="key">esc</span>)</li>
</ul>
</details>
</div>



<!-- full-window drop target -->
<div id="dropTarget"></div>

<!-- File loading code -->
<script>
// TODO: Consider moving each script into its own module for the sake of code
// clarity. 
//-----------------------------------------------------------------------------
// File loading code

window.currentFile = null;

function setFilename(name) {
	document.getElementById("fileName").textContent = name;
}
function readFile(file) {
	console.log("Attempting to read file: '" + file.name + "'");
	setFilename(file.name);

	if (readFile.reader) {
		readFile.reader.abort();
		delete readFile.reader;
	}

	let reader = readFile.reader = new FileReader();
	reader.onload = function(){
		console.log("File was " + reader.result.byteLength + " bytes long.");
		window.body = sv.Body.fromArrayBuffer(reader.result, library);

		bodyDirty();
		cursorDirty();
		resetCamera();
		requestRedraw();
		window.currentFile = file;
	};
	reader.readAsArrayBuffer(file);
}

var dropTarget = document.getElementById("dropTarget");
//dragging into the window also loads files:
dropTarget.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('dragleave', function(evt){
	dropTarget.classList.remove("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('drop', function(evt){
	dropTarget.classList.remove("active");
	try {
		file.value = "";
		window.currentFile = null;
		readFile(evt.dataTransfer.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});

//dragging into the window shows the target:
document.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});

var file = document.getElementById("file");
file.addEventListener('change', function(evt){
	try {
		window.currentFile = null;
		readFile(file.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});
file.addEventListener('click', function(evt){
	file.value = ""; //reset so 'change' event fires
});

document.getElementById("save").addEventListener('click', function(evt){
	console.log("Saving");
	const text = JSON.stringify(body.toData());
	fileSave(text, "solid-knitting.body");
});
document.getElementById("save-yarn-path").addEventListener('click', function(evt){
	console.log("Saving yarn path");
	let text = "";
	let iV = 1;
	for (const cell of body.cells) {
		const xf = cell.xform;
		for (const yarn of cell.template.yarns) {
			for (let iP=0; iP<yarn.pts.length; ++iP) {
				const pt = yarn.pts[iP];
				let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
				text += "v " + at[0]  + " " + at[1] + " " + at[2] + "\n";
			}
			text += "l ";
			for (let iP=0; iP<yarn.pts.length; ++iP) {
				text += iV + " ";
				++iV;
			}
			text += "\n";
		}

	}
	fileSave(text, "solid-knitting-yarn-path.obj");
});

// export machine code 
document.getElementById("export").addEventListener('click', function(evt){
	console.log("Exporting...");
	const text = exportSolidKnitout(body); 
	// .solidknitout, .sk, .solidk -- As a reference to the original knitout extension?
	//console.log(text);
	fileSave(text, "solid-knitting.sk");
});

function exportSolidKnitout(body) {
	// Solid knitout functions for parsing. 
	// Subroutines for string processing. 
	function skPause (str) {
		return "pause \'" + str + "\'\n";
	}
	// For things such as carrier info or add layer 
	function skComment (str) {
		return ";;" + str + "\n";
	}

	// Add scheduling info to solid knitout text (will eventually stop using a single string to store content). 
	function skSchedule (str, cell) {
		var tmp = str;
		if (cell != null && cell.schedulingData != null) {
			if (cell.schedulingData.bed == 'b'){
				tmp = tmp.replaceAll('[Hxy]', cell.schedulingData.HBxy);
			} else{
				tmp = tmp.replaceAll('[Hxy]', cell.schedulingData.HFxy);
			}
			tmp = tmp.replaceAll('[Nx]', cell.schedulingData.Nx);
			tmp = tmp.replaceAll('[CS]', cell.schedulingData.CS);
			tmp = tmp.replaceAll('[HBxy]', cell.schedulingData.HBxy);
			tmp = tmp.replaceAll('[HFxy]', cell.schedulingData.HFxy);
			tmp = tmp.replaceAll('[f/b]', cell.schedulingData.bed);
			tmp = tmp.replaceAll('[D]', cell.schedulingData.D);
		} else {
			console.log("No scheduling data available!")
		}
		if (tmp.includes("[Hxy]")){
			console.log(currCell.schedulingData);
		}
		return tmp;
	}
	const cells = body.cells;
	// Consider writing each line into a document as we go? It could get rather lengthy.
	// Creating Solid knitout for "starting" object. I.e. beginning at block type containing 'yarn-in'? 
	var start = cells.find(cell => (cell != null)&&(cell.template.name == "yarn-in"));
	var initialComments = skComment("Autogenerated Solid Knitout code block.") + skComment("Carrier 1");
	var solidk = initialComments;

	var toVisit = start;

	console.log(start);
	while (toVisit != null){
		var currCell = toVisit; 
		var schedule = skSchedule(currCell.template.machine, currCell);
		solidk = solidk +schedule; 
		// Processing of strings and related information goes here. 

		/* face */
		let currCellCon = currCell.connections;
		let currCellConLen = currCellCon.length; 
		toVisit = null;
		for (let currFace = 0; currFace < currCellConLen; currFace++){
			if (currCellCon[currFace]!= null){
				let adjCell = currCellCon[currFace].cell;
				let adjCellFace = currCellCon[currFace].face;
				if (sv.canConnectFaces(currCell.template.faces[currFace], adjCell.template.faces[adjCellFace])){
					// Edge cases pertaining to loop-next-layer block. 
					if ((adjCell.template.name == 'loop-next-layer')&&(adjCell.template.faces[adjCellFace].type[0] == '-'))){
						//console.log("Pushed cell! -y -> y+ connection.")
						solidk = solidk + skComment('Next layer')
						solidk = solidk + skSchedule(adjCell.template.machine, adjCell);
					}
					if (adjCell.template.faces[adjCellFace].type[1] == 'y' && adjCell.template.faces[adjCellFace].type[0] == '-'){
						// "Pushed cell! -y -> y+ connection."
						toVisit = adjCell; 
					}
				}
			}
		}
		if (currCell.template.name == "yarn-out") {
			toVisit == null; 
		}
	}

	// Consider writing this into a 
	solidk = solidk + skPause("knitting complete, please remove object from machine.");  // Assuming theres no dropping mechanism?

	return solidk;
}

//from knitout-live-visualizer:
function fileSave(sourceText, fileIdentity) {
	var workElement = document.createElement("a");
	if ('download' in workElement) {
		workElement.href = "data:" + 'text/plain' + "charset=utf-8," + escape(sourceText);
		workElement.setAttribute("download", fileIdentity);
		document.body.appendChild(workElement);
		var eventMouse = document.createEvent("MouseEvents");
		eventMouse.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
		workElement.dispatchEvent(eventMouse);
		document.body.removeChild(workElement);
	} else throw 'File saving not supported for this browser';
}

</script>

<!-- Solid Knitting UI code -->
<script type="module">
'use strict';

import * as gm from './code/gm.mjs';
window.gm = gm; //DEBUG

import * as sv from './code/sv.mjs';
window.sv = sv; //DEBUG

window.library = new sv.Library();
window.template = null;
window.body = new sv.Body();

import {Geometry, Program, loadTexture} from './code/gl.mjs';
import {writeHighlightedCode, groupBlocks, groupPasses} from './code/sk.mjs';

document.getElementById("save-knitout").addEventListener('click', function(evt){
	if (groupKnitoutPassesCheckbox.checked) {
		fileSave(groupPasses(knitoutCode.text), "solid-knitting-pattern.sk");
	} else {
		fileSave(knitoutCode.text, "solid-knitting-pattern.sk");	
	}
});

document.getElementById("reallocate-spots").addEventListener('click', function(evt){
	allocateSpots();
});

//-----------------------------------------------------------------------------
// Adapted from yarn visualizer code (from smobj)
// NOTE: based largely on the MDN WebGL tutorials at:
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL

const canvas = document.getElementById("canvas");
const gl = canvas.getContext('webgl', {alpha:false, antialias:false});
window.gl = gl; //DEBUG

//enable extensions:
const ext_WEBGL_depth_texture = gl.getExtension("WEBGL_depth_texture"); //used for postprocessing

const STATUS_LINE = document.getElementById("status-line");
window.STATUS_LINE = STATUS_LINE;

// "enum" representing possible displays
const ViewMode = {
	Pattern: 'Pattern',
	Template: 'Template'
};
let viewMode = ViewMode.Pattern;

//------- camera -------
const camera = {
	target:gm.vec3(0),
	radius:2.5,
	azimuth:0.0,
	elevation:0.0,
	fovy:45.0,
	aspect:1.0
};

window.camera = camera; //DEBUG

camera.computeUp = function camera_computeUp() {
	return gm.vec3(
		Math.cos(this.azimuth)*-Math.sin(this.elevation),
		Math.sin(this.azimuth)*-Math.sin(this.elevation),
		Math.cos(this.elevation)
	);
};

camera.computeRight = function camera_computeRight() {
	return gm.vec3(
		-Math.sin(this.azimuth),
		Math.cos(this.azimuth),
		0.0
	);
};

camera.computeOut = function camera_computeOut() {
	return gm.vec3(
		Math.cos(this.azimuth)*Math.cos(this.elevation),
		Math.sin(this.azimuth)*Math.cos(this.elevation),
		Math.sin(this.elevation)
	);
};

camera.computeAt = function camera_computeAt() {
	return gm.add(this.target, gm.scale(this.radius, this.computeOut()));
};

function resetCamera() {
	let min = gm.vec3(Infinity);
	let max = gm.vec3(-Infinity);

	//TOOD: compute bounding box

	if (min[0] > max[0]) {
		//for now, just some default:
		min[0] = -10.0; min[1] = -10.0; min[2] = -10.0;
		max[0] =  10.0; max[1] =  10.0; max[2] =  10.0;
	}

	camera.target = gm.scale(0.5, gm.add(min,max));

	//console.log("Range: ",min,max);

	camera.radius = 0.5 * (max[1] - min[1]) / Math.tan(0.5 * camera.fovy * Math.PI / 180.0) + 0.5 * (max[2] - min[2]);
	camera.azimuth = Math.PI / 6.0;
	camera.elevation = Math.PI / 4.0;

	requestRedraw();
}
window.resetCamera = resetCamera;

//--- controls ---

const MOUSE = {x:NaN, y:NaN, over:null, grid:null};
let CURSOR = MOUSE; // <-- if anything is selected, set to selection. Otherwise, set to MOUSE
let ACTION = null; //<-- current action; gets all events if not null

let camFlipX = false; //used for camera rotation control

function mouseRay() {
	const origin = camera.computeAt();

	//compute ray direction through mouse:
	const o = camera.computeOut();
	const r = camera.computeRight();
	const u = camera.computeUp();
	const rh = Math.tan(0.5 * camera.fovy / 180.0 * Math.PI); //half of the image plane height
	const rw = rh * camera.aspect; //half of the image plane width

	const direction = gm.sub( gm.add( gm.scale(rw * MOUSE.x, r), gm.scale(rh * MOUSE.y, u)), o);

	return {origin, direction};
}

function mouseDirty() {
	MOUSE.over = null;
	MOUSE.grid = null;

	MOUSE.dirty = true;
	requestRedraw(); //mouse will be updated as part of redraw
}
window.mouseDirty = mouseDirty;

function cursorDirty() {
	mouseDirty(); // always update MOUSE

	// if CURSOR is frozen, we shouldn't update
	if (CURSOR.frozen) return;

	CURSOR.over = null;
	CURSOR.grid = null;

	CURSOR.dirty = true;
	requestRedraw();
}
window.cursorDirty = cursorDirty;

function bodyDirty() {
	visBody.dirty = true;
	visWire.dirty = true;
	visWireCells.dirty = true;
	visTubes.dirty = true;
	requestRedraw();
}
window.bodyDirty = bodyDirty;

function templateDirty() {
	visTemplateBody.dirty = true;
	visTemplateWire.dirty = true;
	visTemplateTubes.dirty = true;
	visTemplateWireCells.dirty = true;
	requestRedraw();
}
window.templateDirty = templateDirty;

function knitoutDirty() {
	knitoutCode.dirty = true;
	requestRedraw();
}
window.knitoutDirty = knitoutDirty; // for debugging

function setMouseOver() {
	delete MOUSE.dirty;
	MOUSE.over = null;
	MOUSE.grid = null;
	if (MOUSE.x !== MOUSE.x) return;
	const ray = mouseRay();

	let close = Infinity;
	

	//faces of cells:
	function isect(a,b,c, cell,face, cellID) {
		const perp = gm.cross(gm.sub(b, a), gm.sub(c, a));

		//offset of the start of the ray from the plane of the triangle:
		const ofs = gm.dot(perp, gm.sub(ray.origin, a));

		//change in offset when moving along direction:
		const step = gm.dot(perp, ray.direction);

		//if can't get to plane of triangle, can't intersect:
		if (step === 0) return;
		if (ofs <= 0 && step <= 0) return;
		if (ofs >= 0 && step >= 0) return;

		//if can't get to plane in time, can't intersect:
		const t = -ofs / step;
		if (t >= close) return;

		//move point to plane of triangle:
		const p = gm.add(ray.origin, gm.scale(t, ray.direction));

		//console.log(`Close to zero(?): ${dot(perp, sub(p,a))}`); //DEBUG

		//barycentric coords:
		const wa = gm.dot(perp, gm.cross(gm.sub(c,b), gm.sub(p,b)));
		const wb = gm.dot(perp, gm.cross(gm.sub(a,c), gm.sub(p,c)));
		const wc = gm.dot(perp, gm.cross(gm.sub(b,a), gm.sub(p,a)));

		//outside the triangle:
		if (wa < 0 || wb < 0 || wc < 0) return;

		close = t;
		MOUSE.over = {cell, face, cellID};
		MOUSE.grid = null;
	}

	for (let cellID = 0; cellID < body.cells.length; ++cellID) {
		const cell = body.cells[cellID];
		if (!checkCellVisible(cell)) continue;
		{ //ray vs bounding box of cell:
			let min = gm.vec3(Infinity);
			let max = gm.vec3(-Infinity);
			for (let v of cell.vertices) {
				min = gm.min(min, v);
				max = gm.max(max, v);
			}
			let t0 = 0;
			let t1 = Infinity;
			function reduce(low, high, origin, direction) {
				//when is low <= origin + t * direction <= high?
				if (direction > 0) {
					t0 = Math.max(t0, (low - origin) / direction);
					t1 = Math.min(t1, (high - origin) / direction);
				} else if (direction < 0) {
					t1 = Math.min(t1, (low - origin) / direction);
					t0 = Math.max(t0, (high - origin) / direction);
				} else {
					if (origin < low || origin > high) {
						t0 = 1;
						t1 = 0;
					}
				}
			}
			for (let d = 0; d < 3; ++d) {
				reduce(min[d], max[d], ray.origin[d], ray.direction[d]);
			}
			if (t0 > t1) continue; //if doesn't intersect bounding box
		}

		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			const face = cell.template.faces[fi];
			for (let i = 2; i < face.indices.length; ++i) {
				const a = cell.vertices[face.indices[0]];
				const b = cell.vertices[face.indices[i-1]];
				const c = cell.vertices[face.indices[i]];
				isect(a,b,c, cell,fi, cellID);
			}
		}
	}

	//also check grid (at z = 0) [but only if not over a face]:
	if (MOUSE.over === null) {
		const ofs = ray.origin[2];
		const step = ray.direction[2];
		if ((ofs < 0 && step > 0) || (ofs > 0 && step < 0)) {
			const t = -ofs / step;
			if (t < close) {
				close = t;
				MOUSE.over = null;
				MOUSE.grid = {
					x:ray.origin[0] + ray.direction[0] * t,
					y:ray.origin[1] + ray.direction[1] * t,
					z:ray.origin[2] + ray.direction[2] * t
				};
			}
		}
	}

}

function setCursorOver() {
	delete CURSOR.dirty;
	setMouseOver(); // update mouse position
	if (CURSOR.frozen) {
		// if a location is selected, do nothing
	} else {
		// otherwise, deep copy mouse position
		CURSOR = {x: MOUSE.x, y: MOUSE.y, over: MOUSE.over, grid: MOUSE.grid};
	}
}

//mouse in elt-is-[-1,1]x[-1,1] space:
function relativeMouse(evt, elt) {
	//based on: https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event
	const rect = elt.getBoundingClientRect();
	return {
		x:2.0 * (evt.clientX - rect.left) / rect.width - 1.0,
		y:-2.0 * (evt.clientY - rect.top) / rect.height + 1.0
	};
}

function selectMouseOver() {
	const oldCursor = {x: CURSOR.x, y: CURSOR.y, over: CURSOR.over, grid: CURSOR.grid};
	if (CURSOR.frozen) {
		oldCursor.frozen = true;
	}

	CURSOR.frozen = false; // unfreeze cursor so that we select even if something is already selected
	setCursorOver();
	CURSOR.frozen = true;
	const newCursor = {x: CURSOR.x, y: CURSOR.y, over: CURSOR.over, grid: CURSOR.grid, frozen: true};

	pushCommand({type: "Select", oldCursor: oldCursor, newCursor: newCursor});
}

canvas.addEventListener('wheel', function(evt){
	evt.preventDefault();
	let amt = evt.deltaY;
	if (evt.deltaMode === 0x01) amt *= 16.0;
	const zoom = Math.pow(0.5, -0.003 * amt);
	camera.radius *= zoom;
	if (camera.radius < 1.0) camera.radius = 1.0;
	if (camera.radius > 1000.0) camera.radius = 1000.0;
	requestRedraw();
});

canvas.addEventListener('mousedown', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mousedown) ACTION.mousedown(evt, mouse);
	} else {
		if (evt.button == 0) {
			startCameraMove();
		}
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	cursorDirty();
	evt.preventDefault();
});

canvas.addEventListener('mousemove', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mousemove) ACTION.mousemove(evt, mouse);
	} else {
		//generally, nothing
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	cursorDirty();
	evt.preventDefault();
});

canvas.addEventListener('mouseup', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mouseup) ACTION.mouseup(evt, mouse);
	} else {
		//generally, nothing
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	cursorDirty();
	evt.preventDefault();
});

// set up command buttons
document.getElementById("relax-shape").onclick = function () { body.relax(); bodyDirty(); };
document.getElementById("select-hovered-template").onclick = function () {
	if (CURSOR.over) {
		setActiveTemplate(CURSOR.over.cell.template);
		requestRedraw();
	} else {
		setActiveTemplate(null);
		requestRedraw();
	}
};
document.getElementById("delete").onclick = function () {
	deleteCell();
	delete CURSOR.frozen;
	cursorDirty();
};
document.getElementById("grab").onclick = startGrabCell;
document.getElementById("start-connection").onclick = function () {
	if (ACTION) {
		if (ACTION.type === "Connect") {
			ACTION.keydown({code: "KeyC"});
		}
	} else {
		startConnectFace();
	}
}
document.getElementById("check-for-cycles").onclick = function () {
	// probably will change keycode. 
	// Run topological sort. 
	if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
	else console.log("No cycles detected in yarn directions");
};
document.getElementById("prev-template").onclick = function () {
	prevTemplate();
	requestRedraw();
};
document.getElementById("next-template").onclick = function () {
	nextTemplate();
	requestRedraw();
};
document.getElementById("prev-compatible-template").onclick = function () {
	prevCompatibleTemplate();
	requestRedraw();
};
document.getElementById("next-compatible-template").onclick = function () {
	nextCompatibleTemplate();
	requestRedraw();
};
document.getElementById("select-hovered-block").onclick = function () {
	selectMouseOver();
	requestRedraw();
};
document.getElementById("undo").onclick = undoLatestCommand;
document.getElementById("escape-from-action").onclick = function () {
	if (ACTION) {
		ACTION.keydown({code : 'Escape'});
	} else if (CURSOR.frozen) {
		delete CURSOR.frozen;
		cursorDirty();
	}
};

window.addEventListener('keydown', function(evt){
	if (evt.code == 'KeyS') { // selection takes priority over everything since it's helpful during actions
		selectMouseOver();
		requestRedraw();
	} else if (ACTION) { // actions take priority over ordinary keybindings
		if (ACTION.keydown) ACTION.keydown(evt);
	} else {
		if (CURSOR.frozen && evt.code == 'Escape') {
			delete CURSOR.frozen;
			cursorDirty();
		}
		if (evt.code == 'KeyZ' && (evt.ctrlKey || evt.metaKey)) { 
			// allow control-z or command-z on all systems since it seems tricky to check which is expected
			undoLatestCommand();
			return;
		} else if (evt.code === 'Space' || evt.code === 'KeyR') { // TODO: allow undo for relax?
			body.relax();
			bodyDirty();
		} else if (evt.code == 'KeyA') {
			addCell();
		} else if (evt.code == 'Enter') {
			if (CURSOR.over) {
				setActiveTemplate(CURSOR.over.cell.template);
				requestRedraw();
			} else {
				setActiveTemplate(null);
				requestRedraw();
			}
		} else if (evt.code == 'KeyX') {
			deleteCell();
			delete CURSOR.frozen;
			cursorDirty();
		} else if (evt.code == 'KeyG') {
			startGrabCell(); //start drag
		} else if (evt.code == 'KeyC') {
			// warning: keybinding also hardcoded into action and button
			startConnectFace(); //start connection
		} else if (evt.code == 'KeyU') {
			// probably will change keycode. 
			// Run topological sort. 
			if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
			else console.log("No cycles detected in yarn directions");
		} else if (evt.code == 'ArrowUp') {
			prevTemplate();
			requestRedraw();
		} else if (evt.code == 'ArrowDown') {
			nextTemplate();
			requestRedraw();
		} else if (evt.code == 'KeyJ') {
			nextCompatibleTemplate();
			requestRedraw();
		} else if (evt.code == 'KeyK') {
			prevCompatibleTemplate();
			requestRedraw();
		} 
		//console.log(evt.code); //when you want more keys
	}
});

// keep track of commands in a circular buffer to implement undo
let commandHistory = {
	commands: Array(50).fill(null),
	latest: 49
};

function pushCommand(command) {
	commandHistory.latest = (commandHistory.latest + 1) % commandHistory.commands.length;
	commandHistory.commands[commandHistory.latest] = command;
}

function undoLatestCommand() {
	const command = commandHistory.commands[commandHistory.latest];
	if (command == null) {
		console.log("reached end of undo history");
		return; // no command to undo
	}

	if (command.type === "addCell") { // {type: "addCell", newCellIndex: newCellIndex}
		unsafeDeleteCell(command.newCellIndex);
	} else if (command.type === "deleteCell") { // {type: "deleteCell", cell: cell, cellIndex: cellIndex}
		unsafeAddCell(command.cell, command.cellIndex);
	} else if (command.type === "confirmGrabCell") {
		console.log("undoing grab");
		// {type: "confirmGrabCell", cellIndex: body.cells.indexOf(cell),
		// 		             startVertices: startVertices, startXform: startXform,
		// 		             endVertices: cell.vertices, endXform: cell.xform}
		const cell = body.cells[command.cellIndex];
		cell.vertices = command.startVertices;
		cell.xform = command.startXform;
		ACTION = null; // just in case
		bodyDirty();
	} else if (command.type === "confirmConnect") {
		console.log("undoing connect");
		// {type: "confirmConnect", cellIndex: body.cells.indexOf(cell), face: face, oldConnection: oldConnection}
		const cell = body.cells[command.cellIndex];
		if (cell.connections[command.face]) { // remove created connection
			const toCell = cell.connections[command.face].cell;
			const toFace = cell.connections[command.face].face;
			toCell.connections[toFace] = null;
		}
		cell.connections[command.face] = command.oldConnection; // restore old connection for cell
		if (command.oldConnection) { // restore old connection for cell's neighbor
			command.oldConnection.cell.connections[command.oldConnection.face] = {cell:cell, face:command.face};
		}
		ACTION = null; // just in case
		bodyDirty();
	} else if (command.type === "Select") {
		CURSOR = command.oldCursor;
	} else if (command.type === "editSchedulingData") {
		// {type: "editSchedulingData", cell: over.cell, field: variableName, oldValue: over.cell.schedulingData[variableName], newValue: textInput.value}
		command.cell.schedulingData[command.field] = command.oldValue;
	} else {
		console.error("unknown command type ", command.type, " in command ", command);
		return;
	}

	// erase command and decrement latest
	commandHistory.commands[commandHistory.latest] = null;
	commandHistory.latest = (commandHistory.latest + commandHistory.commands.length - 1) % commandHistory.commands.length;
}


// TODO: Consider moving each script into its own module for the sake of code
// clarity. 

// https://stackoverflow.com/a/10800402
function stripSpaces(str) {
	return str.replace(/\s/g, '');
}

function listTemplates(templates) {
// <ul id="library">
	const library_list = document.getElementById("library-list");
	library_list.textContent = ''; // clear anything currently in list

	// sort templates by signature
	let signature_names = {}
	for (const name of Object.keys(templates)) {
		signature_names[templates[name].signature()] = name;
	}
	for (const signature of Object.keys(signature_names).sort()) {
		const item = document.createElement('li');
		item.innerHTML = templates[signature_names[signature]].longname;
		item.setAttribute('id', stripSpaces(signature));
		item.onclick = function() {setTemplateFromSignature(stripSpaces(signature));};
		library_list.appendChild(item);
	}
}

function setActiveTemplate(t) {
	template = t;
	const currently_highlighted = document.getElementsByClassName('library-active-template');
	for (let elem of currently_highlighted) {
		elem.classList.remove('library-active-template');
	}
	if (template) {
		const templateElem = document.getElementById(stripSpaces(template.signature()));
		templateElem.classList.add('library-active-template');
		templateElem.scrollIntoView({behavior: "smooth", block: "nearest"});
		// if ()
	}
	templateDirty();
}


// Solid knitting interface code. 

//select next template from library:
// (uses global 'library' and 'template' variables)
function nextTemplate() {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with larger signature than current:
		if (template !== null && t.signature() <= template.signature()) continue;
		//of these, select the smallest:
		if (selected !== null && selected.signature() < t.signature()) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

//select previous template from library:
// (uses global 'library' and 'template' variables)
function prevTemplate() {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with smaller signature than current:
		if (template !== null && t.signature() >= template.signature()) continue;
		//of these, select the largest:
		if (selected !== null && selected.signature() > t.signature()) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

//select next template from library:
// (uses global 'library' and 'template' variables)
function nextCompatibleTemplate() {
	if (CURSOR.over === null) return nextTemplate();

	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;

	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with larger signature than current:
		if (template !== null && t.signature() <= template.signature()) continue;
		//of these, select the smallest:
		if (selected !== null && selected.signature() < t.signature()) continue;
		if (checkTemplateCompatible(cell, face, t) === null) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

//select previous template from library:
// (uses global 'library' and 'template' variables)
function prevCompatibleTemplate() {
	if (CURSOR.over === null) return prevTemplate();

	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;

	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with smaller signature than current:
		if (template !== null && t.signature() >= template.signature()) continue;
		//of these, select the largest:
		if (selected !== null && selected.signature() > t.signature()) continue;
		if (checkTemplateCompatible(cell, face, t) === null) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

function setTemplateFromSignature(stripped_signature) {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		if (stripSpaces(t.signature()) == stripped_signature) {
			selected = t;
		}
	}
	setActiveTemplate(selected);
}

// if template can be attached to face of cell, return the resulting cell
// otherwise, return null
function checkTemplateCompatible(cell, face, template, verbose = false) {
	// Cannot connect if hovered face is already connected. 
	if (cell.connections[face]) return null;

	let compat = [];
	for (let f = 0; f < template.faces.length; ++f) {
		if (sv.canConnectFaces(cell.template.faces[face], template.faces[f])) {
			compat.push(f);
		}
	}

	if (!compat.length) return null; //no compatible faces

	const tf = compat[0];

	console.assert(cell.template.faces[face].indices.length === template.faces[tf].indices.length, "Cell and connecting template face have same count of vertices.");

	//vertex lists that should connect:
	const cellVerts = [];
	const templateVerts = [];
	sv.forAlignedIndices(cell.template.faces[face], template.faces[tf], (i, ti) => {
		const cv = cell.template.faces[face].indices[i];
		const tv = template.faces[tf].indices[ti];
		cellVerts.push(cell.vertices[cv]);
		templateVerts.push(template.vertices[tv]);
	});

	const xform = gm.rigidTransform(templateVerts, cellVerts);

	const preview = sv.Cell.fromTemplate(template, xform);

	//record the fact that the connection exists:
	// preview.connections[tf] = {cell:cell, face:face};

	//see if there are other connections that might make sense:
	// TODO: center is a bad proxy for faces when we're looking at faces of different shapes
	let centers = [];
	for (let fi = 0; fi < preview.template.faces.length; ++fi) {
		const face = template.faces[fi];
		let center = gm.vec3(0.0);
		for (let vi of face.indices) {
			center = gm.add(center, preview.vertices[vi]);
		}
		center = gm.scale(1.0 / face.indices.length, center);
		centers.push(center);
	}

	//Check all faces with compatible types for overlapping centers:
	//TODO: less brute force than this!
	for (let cell of body.cells) {
		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			// if (cell.connections[fi] !== null) continue;
			const face = cell.template.faces[fi];

			// if (face.type === 'x') continue;
			let center = gm.vec3(0.0);
			for (let vi of face.indices) {
				center = gm.add(center, cell.vertices[vi]);
			}
			center = gm.scale(1.0 / face.indices.length, center);

			for (let pfi = 0; pfi < preview.template.faces.length; ++pfi) {
				const dist2 = gm.dist2(center, centers[pfi]);

				if (dist2 >= 0.1 * 0.1) continue;

				// check if faces are compatible
				if (face.type ==='x' && preview.template.faces[pfi].type === 'x') {
					// this case is okay, but not a connection
					continue;
				} else if (preview.connections[pfi] != null) {
					if (verbose) console.log("preview connection already exists");
					return null;
				} else if (face.type ==='x' || preview.template.faces[pfi].type === 'x') {
					if (verbose) console.log("face.type is x");
					return null;
				} else if (cell.connections[fi] !== null) {
					if (verbose) console.log("cell connection already exists");
					return null;
				} else if (!sv.canConnectFaces(preview.template.faces[pfi], face)) {
					if (verbose) console.log("faces incompatible");
					return null;
				}

				// otherwise, we found a connection
				preview.connections[pfi] = {cell:cell, face:fi};
			}
		}
	}

	return preview;
}

//return a cell built as if by pressing 'addCell' at this very location:
// (or 'null' if that wouldn't happen)
function previewCell() {
	//can't add a cell if current template is no template:
	if (template === null) return null;

	if (CURSOR.grid !== null) {
		//transform that puts center of cell at cursor position on the grid:
		const xform = gm.mat4x3(
			1,0,0,
			0,1,0,
			0,0,1,
			CURSOR.grid.x, CURSOR.grid.y, 0
		);
		return sv.Cell.fromTemplate(template, xform);
	}

	if (CURSOR.over !== null) {
		const cell = CURSOR.over.cell;
		const face = CURSOR.over.face;

		return checkTemplateCompatible(cell, face, template);
	}

	return null;
}
window.previewCell = previewCell; //DEBUG

// add a cell to the body at a specified index in the cell list
// does not perform correctness checks or store this action in the undo queue
function unsafeAddCell(cell, index) {
	if (cell === null) return;

	//if the cell *does* exist, hook up the other side of any connections it has:
	for (let f = 0; f < cell.connections.length; ++f) {
		const con = cell.connections[f];
		if (con === null) continue;
		console.assert(con.cell.connections[con.face] === null, "Shouldn't be over-writing connections.");
		con.cell.connections[con.face] = {cell:cell, face:f};
	}

	body.cells.splice(index, 0, cell);

	//update UI and redraw:
	cursorDirty();
	bodyDirty();
}

/**
 * addCell (): 
 * Adds cell adjacent to selected face. */
function addCell() {
	if (CURSOR.dirty) setCursorOver();

	//is there a cell that could exist here? Ask the preview function:
	const preview = previewCell();

	//if doesn't exist, don't create anything:
	if (preview === null) return;

	const newCellIndex = body.cells.length;
	unsafeAddCell(preview, newCellIndex);

	// Record command in undo queue
	pushCommand({type: "addCell", newCellIndex: newCellIndex});

	// Check global correctness from preview cell. 
	if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
}


// Topological sort to check correctness using BFS using Kahn's accross entire implementation.
// Overall complexity of O(|E| + |V).
function checkGlobalCellCorrectness() {
	// Dictionary of visited cells {cell, visit #}
	let inDegrees = new Map();

	// bodyLen == Expected count of elements in topological sort. (based on the indegree value) 
	let bodyLen = body.cells.length;

	// Initialize all cells in body into dictionary.
	for (let i = 0; i < bodyLen; i++) inDegrees.set(body.cells[i], 0);

	// Iterate accross all cell connections.
	for (let i = 0; i < bodyLen; i++){
		let currCell = body.cells[i]; /* cell */
		let currCellCon = currCell.connections;
		let currCellConLen = currCellCon.length;

		// Calculate indegrees for all adjacent/connected cells.
		for (let v = 0; v < currCellConLen; v++){
			let currFace = v; /*face*/
			let adjCellCon = currCellCon[currFace]

			if (adjCellCon != null){
				let adjCellFace = adjCellCon.face /* toFace */
				let adjCell = adjCellCon.cell /* toCell */
				
				// Assert that only yarn directions are taken into account. 
				// Only one direction is taken into account, in this case were 
				// assume the current cell (-y) connects with adjacent cell 
				// (+y) to avoid double counting. 
				// I.e. both (+y) -> (-y) and (-y) -> (+y). 
				if (sv.canConnectFaces(currCell.template.faces[currFace], adjCell.template.faces[adjCellFace]) &&
					(currCell.template.faces[currFace].type[1] == 'y') &&
					(currCell.template.faces[currFace].type[0] == '-')){
					// Increment inDegree calculation.
					let val = inDegrees.get(adjCell);
					inDegrees.set(adjCell, ++val);
				}
			}
		}
	}
	
	let count = 0; 

	// Queue of cells to visit, based on cells with inDegree 0.
	let toVisit =  body.cells.filter(cell => (inDegrees.get(cell) == 0));

	// Array to keep track of topological order. 
	let topOrder = [];

	// Topological ordering of vertices. 
	while (toVisit.length != 0){
		// Shift topmost element: 
		let currCell = toVisit.shift(); /* face */
		topOrder.push(currCell);

		let currCellCon = currCell.connections;
		let currCellConLen = currCellCon.length;

		// Calculate indegrees for all adjacent/connected cells.
		for (let v = 0; v < currCellConLen; v++){
			let currFace = v; /*face*/
			let adjCellCon = currCellCon[currFace]

			if (adjCellCon != null){
				let adjCellFace = adjCellCon.face /* toFace */
				let adjCell = adjCellCon.cell /* toCell */
				
				if (sv.canConnectFaces(currCell.template.faces[currFace], adjCell.template.faces[adjCellFace]) &&
					(currCell.template.faces[currFace].type[1] == 'y') &&
					(currCell.template.faces[currFace].type[0] == '-')){
					let val = inDegrees.get(adjCell); 
					if (--val == 0) toVisit.push(adjCell);
				}
			}
		}
		count++;
	}
	return count == bodyLen; 
}
// computes a needle, frontHolder, backHolder, layer, direction, and yarnID for each cell, storing these in cell.schedulingData
// currently computes locations for knit, next-row, yarn-next-layer, loop-next-layer, cast-on, bind-off
function allocateSpots(x0=1, y0=4) {
	// identify extreme stitch
	// let origin = null;
	// for (let cell of body.cells) {
	// 	if (cell.template.name != "knit") continue;
	// 	if (origin === null) {
	// 		origin = gm.xformTranslation(cell.xform);
	// 	} else {
	// 		const cellPosition = gm.xformTranslation(cell.xform);
	// 		origin = gm.min(origin, cellPosition);
	// 	}
	// }

	// follow yarn through body
	function getYarnExitFace(cell) {
		for (let iF=0; iF<cell.template.faces.length; ++iF) {
			if (cell.template.faces[iF].type.startsWith("+y")) return iF;
		}
		return null;
	}

	// clear schedulingData and look for yarn-in to start
	let currCell = null;
	for (let cell of body.cells) {
		cell.schedulingData = {
			direction : null,
			waleDirection : null,
			bed : null,
			embedding : null,
			HFxy : null,
			HBxy : null,
			Nx : null, 
			D : null,
			CS : null,
			layer : null
		};
		if (cell.template.name === "yarn-in") {
			currCell = cell;
		}
	}
	if (currCell == null) {
		console.error("spot allocation failed: no yarn-in cell found");
		return;
	}

	let exitFace = getYarnExitFace(currCell);
	let currDirection = (exitFace === 2) ? -1  // TODO: remove magic indices
	                  : (exitFace === 4) ? 1  // TODO: remove magic indices
	                  : null;
	if (currDirection == null) {
		console.error("spot allocation failed: unrecognized yarn-in signature ", currCell.signature());
		return;
	}

	let currBed = 1; // somewhat confusingly, bed is the stitch that the bed gets made on, which is opposite to the bed used for the needle
	let currWaleDirection = 1; // TODO: how do you determine this?
	currCell.schedulingData.embedding = gm.vec3(0, 0, 0);

	//== find directions & beds for all stitches and embeddings for knit stitches (abstract 3d coordinates that we'll use to get needle/holder positions)
	let xMax=-10, yMax=-10, xMin=10, yMin=10, zMin=10;
	while (currCell != null) {
		currCell.schedulingData.direction = (currDirection > 0) ? "+" : "-";
		currCell.schedulingData.waleDirection = (currWaleDirection > 0) ? "+" : "-";
		currCell.schedulingData.bed = (currBed > 0) ? "f" : "b";
		if (currCell.template.name.startsWith("yarn-next-row")) {
			currDirection *= -1;
		} else if (currCell.template.name.startsWith("yarn-next-layer")) {
			currWaleDirection *= -1; // TODO: does this depend on same vs opposite?
			currDirection *= -1;
			currBed *= -1;
		}

		//== locate yarn out and propagate embedding. Leave the embedding of yarn-next-row/yarn-next-layer blocks to be filled in later
		let exitFace = null;
		for (let iF=0; iF<currCell.template.faces.length; ++iF) {
			const faceType = currCell.template.faces[iF].type;

			if (faceType.startsWith("+y")) exitFace = iF;

			if (currCell.connections[iF] == null || currCell.template.name.startsWith("yarn-next") || currCell.template.name.startsWith("loop-next")) continue;
			const connection = currCell.connections[iF].cell;
			if (connection.template.name.startsWith("yarn-next") || connection.template.name.startsWith("loop-next")) continue;

			let offset = null;
			if (faceType.startsWith("+y")) {
				offset = gm.vec3(currDirection, 0, 0);
			} else if (faceType.startsWith("-y")) {
				offset = gm.vec3(-currDirection, 0, 0);
			} else if (faceType.startsWith("+L")) {
				offset = gm.vec3(0, 0, 1);
			} else if (faceType.startsWith("-L")) {
				offset = gm.vec3(0, 0, -1);
			} else if (faceType.startsWith("+l")) {
				offset = gm.vec3(0, currWaleDirection, 0);
				// special case for cast-on which shares location
				if (currCell.template.name.startsWith("cast-on")) offset = gm.vec3(0, 0, 0);
			} else if (faceType.startsWith("-l")) {
				offset = gm.vec3(0, -currWaleDirection, 0);
				// special case for bind-off which shares location
				if (currCell.template.name.startsWith("bind-off")) offset = gm.vec3(0, 0, 0);
			} else {
				console.log("cannot propagate face type ", faceType);
				continue;
			}

			const connectionEmbedding = gm.add(currCell.schedulingData.embedding, offset);
			if (connection.schedulingData.embedding == null) {
				connection.schedulingData.embedding = connectionEmbedding;
				const name = connection.template.name;
				if (!(name.startsWith("yarn-out") || name.startsWith("cast-on") || name.startsWith("bind-off"))) { // ignore cast-on, bind-off, yarn-out when computing bounds
					xMax = Math.max(xMax, connectionEmbedding[0]);
					yMax = Math.max(yMax, connectionEmbedding[1]);
					xMin = Math.min(xMin, connectionEmbedding[0]);
					yMin = Math.min(yMin, connectionEmbedding[1]);
					zMin = Math.min(yMin, connectionEmbedding[2]);
				}
			} else {
				// don't check yarn-next-row/yarn-next-layer or cast-on/bind-off blocks for now since they have special rules
				if (connection.template.name.startsWith("yarn-next")
				   || connection.template.name.startsWith("loop-next")
				   || connection.template.name.startsWith("cast-on")  || currCell.template.name.startsWith("cast-on")
				   || connection.template.name.startsWith("bind-off") || currCell.template.name.startsWith("bind-of")) continue;

				if ((Math.abs(connectionEmbedding[0] - connection.schedulingData.embedding[0]) > 0.01)
				 || (Math.abs(connectionEmbedding[1] - connection.schedulingData.embedding[1]) > 0.01)
				 || (Math.abs(connectionEmbedding[2] - connection.schedulingData.embedding[2]) > 0.01)) {
					console.error("mismatched neighbors ", currCell, connection);
				}
			}
		}

		if (exitFace != null) {
			currCell = currCell.connections[exitFace].cell;
		} else {
			currCell = null;
		}
	}

	// shift embedding to start at the origin and assign embeddings for loop-next-layer blocks
	for (let cell of body.cells) {
		if (cell.schedulingData.embedding) {
			cell.schedulingData.embedding[0] -= xMin;
			cell.schedulingData.embedding[1] -= yMin;
			cell.schedulingData.embedding[2] -= zMin;
		} else if (cell.template.name.startsWith("loop-next-layer")) {
			// make sure to look at loop in to specify correct holder for xfer
			for (let iF=0; iF<cell.template.faces.length; iF++){
				if (!cell.connections[iF]) continue;
				if (cell.template.faces[iF].type.startsWith("-l")) {
					// loop in
					const bed = cell.connections[iF].cell.schedulingData.bed
					cell.schedulingData.bed = bed;
					cell.schedulingData.embedding = gm.copyVec3(cell.connections[iF].cell.schedulingData.embedding);
					if (bed === "f") {
						cell.schedulingData.embedding[1] += 1; // xfer to front -> bump up y coord
					} else {
						cell.schedulingData.embedding[1] -= 1; // xfer to back -> bump down y coord
					}
					// move z coord between layers
					cell.schedulingData.embedding[2] += 0.5;
				}
			}
		}
	}
	xMax -= xMin; yMax -= yMin; // shift maxima
	xMin = 0; yMin = 0; zMin = 0; // shift minima

	function holderPositions(x, y) {
		return {f: "hf" + (x+x0) + "," + (y0+y), b: "hb" + (x+x0) + "," + (y0+yMax-y)};
	}

	for (let cell of body.cells) {
		if (cell.schedulingData.embedding != null) {
			let x = cell.schedulingData.embedding[0], y = cell.schedulingData.embedding[1], z = cell.schedulingData.embedding[2];
			// somewhat confusingly, bed is the stitch that the bed gets made on, which is opposite to the bed used for the needle
			const needleBed = (cell.schedulingData.bed === "f") ? "b" : "f";
			const holders = holderPositions(x, y);
			cell.schedulingData.HFxy = holders.f;
			cell.schedulingData.HBxy = holders.b;
			cell.schedulingData.Nx = needleBed + (x+x0); 
			cell.schedulingData.D = cell.schedulingData.direction;
			cell.schedulingData.CS = [1];

			// not currently used
			cell.schedulingData.layer = z;
		}

	}
}

// add a cell to the body at a specified index in the cell list
// does not perform correctness checks or store this action in the undo queue
function unsafeDeleteCell(index) {
	const cellConnections = body.cells[index].connections;

	// Update all connections referencing current cell.
	for (let i = 0; i < cellConnections.length; i++) {
		if(cellConnections[i] != null){
			const currCell = cellConnections[i].cell;
			const currFace = cellConnections[i].face;
			currCell.connections[currFace] = null;
		}
	}

	// Remove current cell from body. 
	body.cells.splice(index, 1);

	// Update UI and redraw:
	cursorDirty();
	bodyDirty();
}

/**
 * deleteCell (): 
 * Deletes currently selected cell, regardless of face type. 
 * Consider: When cell is selected to delete a box, instead of highlighting
 * selected face, we should highlight selected cell. */
function deleteCell() {
	if (CURSOR.dirty) setCursorOver();
	if (!CURSOR.over) return;

	const cell = CURSOR.over.cell;
	const cellIndex =  body.cells.indexOf(cell);

	unsafeDeleteCell(cellIndex);

	// Record command in undo queue
	pushCommand({type: "deleteCell", cell: cell, cellIndex: cellIndex});

	// Check global correctness from preview cell. 
	if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
}

/**
 * startConnectFace()
 * Start connecting current face
 */
function startConnectFace() {
	if (ACTION !== null) return;
	if (CURSOR.dirty) setCursorOver();
	if (!CURSOR.over) return;
	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;
	// let oldCURSOR = {x: CURSOR.x, y: CURSOR.y, over: CURSOR.over, grid: CURSOR.grid };
	// if (CURSOR.frozen) oldCURSOR.frozen = true;
	delete CURSOR.frozen;

	//is face already connected?
	const oldConnection = cell.connections[face];

	function clearConnection() {
		if (cell.connections[face] !== null) {
			const toCell = cell.connections[face].cell;
			const toFace = cell.connections[face].face;
			console.assert(toCell.connections[toFace] !== null
			 && toCell.connections[toFace].cell === cell
			 && toCell.connections[toFace].face === face, "connections should be reflexive");
			toCell.connections[toFace] = null;
			cell.connections[face] = null;
			bodyDirty();
		}
	}

	clearConnection();

	function setConnection() {
		if (!setConnection.pending) return; //HACK: allow cancelling past end-of-action
		setConnection.pending = false;

		clearConnection();
		if (CURSOR.dirty) setCursorOver();
		if (!CURSOR.over) return;
		const toCell = CURSOR.over.cell;
		if (toCell === cell) return; //can't self-connect
		const toFace = CURSOR.over.face;
		if (toCell.connections[toFace]) return; //can't double-connect

		if (!sv.canConnectFaces(cell.template.faces[face], toCell.template.faces[toFace])) return;


		//make the connection:
		cell.connections[face] = {cell:toCell, face:toFace};
		toCell.connections[toFace] = {cell:cell, face:face};

		bodyDirty();
	}

	function cancelConnect() {
		console.log("Cancelling connect.");
		setConnection.pending = false;
		cell.connections[face] = oldConnection;
		if (oldConnection) {
			oldConnection.cell.connections[oldConnection.face] = {cell:cell, face:face};
		}
		bodyDirty();
		ACTION = null;
	}

	console.log("Starting connect.");

	ACTION = {
		type: "Connect",
		mousedown:(evt,mouse) => {
			if (evt.button === 0) {
				startCameraMove();
			} else if (evt.button === 2) {
				cancelConnect();
			}
		},
		//nothing: mouseup:(evt,mouse) => { },
		mousemove:(evt,mouse) => {
			if (!setConnection.pending) {
				setConnection.pending = true;
				window.requestAnimationFrame( setConnection );
			}
		},
		keydown:(evt) => {
			if (evt.code === 'KeyC') {
				console.log("Confirming connect.");
				setConnection.pending = false;
				ACTION = null;
				// CURSOR = oldCURSOR;
				pushCommand({type: "confirmConnect", cellIndex: body.cells.indexOf(cell), face: face, oldConnection: oldConnection});
			} else if (evt.code === 'Escape') {
				cancelConnect();
				CURSOR = oldCURSOR;
			}
		},
	};


}


/**
 * startGrabCell()
 * Grab (start moving) current cell.
 */
function startGrabCell() {
	if (ACTION !== null) return;

	if (CURSOR.dirty) setCursorOver();

	if (!CURSOR.over) return;


	const cell = CURSOR.over.cell;
	const startXform = cell.xform;
	const startVertices = [];
	let center = gm.vec3(0);
	for (const v of cell.vertices) {
		startVertices.push(gm.vec3(v));
		center = gm.add(center, v);
	}
	center = gm.scale(1 / cell.vertices.length, center);

	const right = camera.computeRight();
	const up = camera.computeUp();
	const out = camera.computeOut();

	function mousePt() {
		const ray = mouseRay();
		const offset = gm.dot(gm.sub(ray.origin, center), out);
		const step = gm.dot(ray.direction, out);
		if (Math.abs(step) < 1e-3 * Math.abs(offset)) return null;
		const t = -offset / step;
		return gm.add(ray.origin, gm.scale(t, ray.direction));
	}

	const begin = mousePt();
	if (begin === null) {
		console.warn("Trying to start drag from null point -- cancelling.");
		return;
	}

	function cancelGrab() {
		console.log("Cancelling grab.");
		cell.vertices = startVertices;
		cell.xform = startXform;
		ACTION = null;
		bodyDirty();
	}

	ACTION = {
		mousedown:(evt,mouse) => {
			if (evt.button == 0) {
				console.log("Confirming grab.");
				pushCommand({type: "confirmGrabCell", cellIndex: body.cells.indexOf(cell),
				             startVertices: startVertices, startXform: startXform,
				             endVertices: cell.vertices, endXform: cell.xform});
				ACTION = null;
				bodyDirty();
			} else if (evt.button == 2) {
				cancelGrab();
			}
		},
		//nothing: mouseup:(evt,mouse) => { },
		mousemove:(evt,mouse) => {
			MOUSE.x = mouse.x;
			MOUSE.y = mouse.y;
			const at = mousePt();
			if (at !== null) {
				const delta = gm.sub(at,begin);
				for (let i = 0; i < cell.vertices.length; ++i) {
					cell.vertices[i] = gm.add(startVertices[i], delta);
				}
				cell.xform = gm.rigidTransform(cell.template.vertices, cell.vertices); //could compute directly from starting xform but this is not performace-critical code
				bodyDirty();
			}
		},
		keydown:(evt) => {
			if (evt.code === 'Escape') {
				cancelGrab();
			}
		}
	};
}

/**
 * startCameraMove()
 */
function startCameraMove() {
	let oldACTION = ACTION;
	camFlipX = (camera.computeUp()[2] < 0.0);

	ACTION = {
		//ignore: mousedown:(evt,mouse) => { },
		mouseup:(evt,mouse) => {
			if (evt.button === 0) {
				ACTION = oldACTION;
				return;
			}
		},
		mousemove:(evt,mouse) => {
			if (MOUSE.x !== MOUSE.x) return;
			if (evt.shiftKey) {
				const up = camera.computeUp();
				const right = camera.computeRight();

				const x = camera.radius * (mouse.x - MOUSE.x) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI) * camera.aspect;
				const y = camera.radius * (mouse.y - MOUSE.y) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI);

				camera.target = gm.sub(camera.target, gm.add(gm.scale(x, right), gm.scale(y, up)));
			} else {
				const deltaToAngle = 2.0 * camera.fovy / 180.0 * Math.PI;
				camera.azimuth += (camFlipX ? -1.0 : 1.0) * -(mouse.x - MOUSE.x) * camera.aspect * deltaToAngle;
				camera.elevation -= (mouse.y - MOUSE.y) * deltaToAngle;
			}
			requestRedraw();
		}
	};
}

//--- vector math library ---
//TODO: clean this up and move to its own module

function lookAt(eye, target, up) {
	var out = gm.normalize(gm.sub(eye, target));
	var proj = gm.dot(up, out);
	up = gm.normalize( gm.sub(up, gm.scale(proj, out) ) );

	var right = gm.cross(up, out);

	var offset = gm.vec3(-gm.dot(eye, right), -gm.dot(eye, up), -gm.dot(eye, out));

	return new Float32Array([
		right[0], up[0], out[0], 0.0,
		right[1], up[1], out[1], 0.0,
		right[2], up[2], out[2], 0.0,
		offset[0], offset[1], offset[2], 1.0
	]);
}

function perspective(fovy, aspect, zNear) {
	var f = 1 / Math.tan(fovy/2 * Math.PI / 180.0);
	return new Float32Array([
		f / aspect, 0.0, 0.0, 0.0,
		0.0, f, 0.0, 0.0,
		0.0, 0.0, -1, -1.0,
		0.0, 0.0,-2.0 * zNear, 0.0
	]);
}
function mul(A, B) {
	var out = new Float32Array(16);
	for (var r = 0; r < 4; ++r) {
		for (var c = 0; c < 4; ++c) {
			var val = 0.0;
			for (var k = 0; k < 4; ++k) {
				val += A[k * 4 + r] * B[c * 4 + k];
			}
			out[4 * c + r] = val;
		}
	}
	return out;
}

function computeMVP() {
	/*//DEBUG:
	return new Float32Array([
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0
	]);*/
	const P = perspective(camera.fovy, camera.aspect, 0.1);
	const up = camera.computeUp();
	const MV = lookAt(
		camera.computeAt(),
		camera.target,
		up
	);
	return mul(P, MV);
}

//------- benchmark -------

/*
function benchmark() {
	console.log("Running benchmark....");

	//Okay, how to benchmark renderer? Consistent frame size, camera position, yarns.

	canvas.style.width = "1024px";
	canvas.style.height = "1024px";

	setBenchmarkYarns();

	camera.target = {x:0.0, y:0.0, z:0.0};
	camera.radius = 37;
	camera.azimuth = 0.0;
	camera.elevation = 0.0;
	camera.fovy = 60.0;
	camera.aspect = 1.0;

	let before = performance.now();
	let iters = 0;
	while (iters < 1000) {
		++iters;
		redraw();
		gl.finish();
		let after = performance.now();
		if (after - before > 2000) break;
	}
	let total = performance.now() - before;
	console.log("Did " + iters + " iterations in " + total + "ms.");
	let result = iters.toString() + " iterations, avg " + total/iters + "ms per";
	document.getElementById("benchmark-result").innerText = result;
}

document.getElementById("benchmark").addEventListener('click', benchmark);
*/

//------- rendering -------

//very simple shader program for vertex-colored things:
const colorProgram = new Program(gl,
`
	uniform mat4 LOCAL_TO_CLIP;

	attribute vec4 Position;
	attribute vec3 Normal;
	attribute vec4 Color;

	varying vec4 color;
	varying vec3 normal;

	void main() {
		gl_Position = LOCAL_TO_CLIP * Position;
		color = Color;
		normal = Normal;
	}
`,`
	uniform highp vec3 HEMI_DIRECTION;
	uniform lowp vec4 TINT;
	varying lowp vec4 color;
	varying highp vec3 normal;
	void main() {
		highp vec3 n = normalize(normal);
		//upper dome light:
		highp vec3 light = mix(vec3(0.1), vec3(1.0), 0.5*dot(n, HEMI_DIRECTION)+0.5);
		gl_FragColor = TINT * vec4(color.rgb * light, color.a);
	}
`);
window.colorProgram = colorProgram; //DEBUG

const textureProgram = new Program(gl,
`
	uniform mat4 LOCAL_TO_CLIP;

	attribute vec4 Position;
	attribute vec3 Normal;
	attribute vec2 UV;
	attribute vec4 Color;
	attribute float CellID;

	varying vec4 color;
	varying vec2 uv;
	varying vec3 normal;
	varying float cellID;

	void main() {
		gl_Position = LOCAL_TO_CLIP * Position;
		color = Color;
		uv = UV;
		normal = Normal;
		cellID = CellID;
	}
`,`
	uniform highp vec3 HEMI_DIRECTION;
	uniform lowp vec4 TINT;
	uniform lowp float TEX_STRENGTH;
	varying lowp vec4 color;
	varying highp vec2 uv;
	varying highp vec3 normal;
	varying highp float cellID;
    uniform sampler2D uSampler;
    uniform highp float selectedCellID;
	uniform lowp vec4 selectedColor;
	void main() {
		highp vec3 n = normalize(normal);
		//upper dome light:
		highp vec3 light = mix(vec3(0.1), vec3(1.0), 0.5*dot(n, HEMI_DIRECTION)+0.5);

		// treat texture as a mask
      	lowp float mask = texture2D(uSampler, uv).r;
      	mask = (1.-TEX_STRENGTH) + TEX_STRENGTH * (1. + mask) / 2.;
      	highp float selected = (abs(cellID - selectedCellID) < 0.01) ? 1. : 0.;
      	lowp vec4 compositeColor = selected * selectedColor + (1.-selected) * color;
		gl_FragColor = TINT * vec4(mask * compositeColor.rgb * light, color.a);
	}
`);
window.textureProgram = textureProgram; //DEBUG


//when using a data view to store Float32 values, do they need to be marked as little endian?
const FLOAT32_LITTLE_ENDIAN = function() {
	let array = new ArrayBuffer(4);
	let f32 = new Float32Array(array);
	let data = new DataView(array);
	f32[0] = 1.0;
	if (data.getFloat32(0, false) === f32[0]) {
		assert(data.getFloat32(0, true) !== f32[0]);
		return false;
	} else if (data.getFloat32(0, true) === f32[0]) {
		assert(data.getFloat32(0, false) !== f32[0]);
		return true;
	}
};

class Grid extends Geometry {
	constructor() {
		const BYTES_PER_ATTRIB = 4*2 + 1*4;
		const RADIUS = 10;

		const arrayBuffer = new ArrayBuffer(4*(2*RADIUS+1+1) * BYTES_PER_ATTRIB);
		const data = new DataView(arrayBuffer);

		let dataOffset = 0;

		function attrib(x,y, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		/*
		//TODO: maybe eventually have axis at origin
		//axes:
		line({x:0,y:0,z:0},{x:5,y:0,z:0}, 0xff0000ff);
		line({x:0,y:0,z:0},{x:0,y:5,z:0}, 0x00ff00ff);
		line({x:0,y:0,z:0},{x:0,y:0,z:5}, 0x0000ffff);
		*/


		for (let x = -RADIUS; x <= RADIUS; ++x) {
			if (x === 0) {
				attrib(x,-RADIUS, 0x008800ff);
				attrib(x, 0, 0x008800ff);
				attrib(x, 0, 0x88ff88ff);
				attrib(x, RADIUS, 0x88ff88ff);
			} else {
				const col = (x == 0 ? 0x88ff88ff : 0x888888ff);
				attrib(x,-RADIUS, 0x888888ff);
				attrib(x, RADIUS, 0x888888ff);
			}
		}
		for (let y = -RADIUS; y <= RADIUS; ++y) {
			if (y === 0) {
				attrib(-RADIUS,y, 0x880000ff);
				attrib( 0,y, 0x880000ff);
				attrib( 0,y, 0xff8888ff);
				attrib( RADIUS,y, 0xff8888ff);
			} else {
				attrib(-RADIUS,y, 0x888888ff);
				attrib( RADIUS,y, 0x888888ff);
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		const buffer = gl.createBuffer();
		const count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);

		const attribs = {
			Position:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*2},
			Normal:[0.0, 0.0, 1.0]
		};

		super(gl, attribs, gl.LINES, count);
	}
}
const grid = new Grid();
window.grid = grid; //DEBUG

//Some predefined colors:
const COLOR_OUTPUT_WARNING = 0x881111ff;
const COLOR_INPUT_WARNING = 0xff2222ff;
const COLOR_OUTPUT = 0x888888ff;
const COLOR_INPUT = 0xffffffff;

//helper for color conversion from '#rrggbb', '#rrggbbaa', '#rgb', and '#rgba' to 0xrrggbbaa
function css2Uint32(color) {
	let val;
	if        (color.length === 9) {
		val = parseInt('0x' + color.substr(1));
	} else if (color.length === 7) {
		val = parseInt('0x' + color.substr(1)) * 256 + 255;
	} else if (color.length === 5) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		const a = (val & 0x000f);
		//why are these not bit-shifts? because those coerce numbers to *signed* int32s integers (vs remaining float64's, which have 50-ish bits of integer precision)
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + (a * 16 + a);
	} else if (color.length === 4) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + 255;
	}
	return val;
}

function rgb2Uint32(color) {
	let val;
	val = Math.max(0, Math.min(255, Math.round(255 * color[0])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[1])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[2])));
	val = val * 256 + 255;
	return val;
}

function rgba2Uint32(color) {
	let val;
	val = Math.max(0, Math.min(255, Math.round(255 * color[0])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[1])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[2])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[3])));
	return val;
}

function checkCellVisible(cell) {
	let zmax = null, zmin = null;
	for (const v of cell.vertices) {
		if (zmax == null || v[2] > zmax) zmax = v[2];
		if (zmin == null || v[2] < zmin) zmin = v[2];
	}

	// const h = zmax - zmin;
	const h = 1; //HACK: standardize height to 1?
	const layer = Math.round((zmax + zmin) / (2 * h));
	const layerVisibilityBoxes = document.getElementById("layer-visibility-form");
	return !(layer >= 0 && layer < layerVisibilityBoxes.length) || layerVisibilityBoxes[layer].checked;
}

class VisBody extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 4*3 + 1*4; //Position, Normal, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3},
		};

		super(gl, attribs, gl.TRIANGLES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				totalAttribs += 3 * (face.indices.length - 2);
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, nx,ny,nz, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, nx, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, ny, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, nz, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}
		
		function triangle(va,vb,vc, color) {
			let n = gm.normalize(gm.cross(gm.sub(vb, va), gm.sub(vc, va)));
			attrib(va[0],va[1],va[2], n[0],n[1],n[2], color);
			attrib(vb[0],vb[1],vb[2], n[0],n[1],n[2], color);
			attrib(vc[0],vc[1],vc[2], n[0],n[1],n[2], color);
		}
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				//TODO: compute normals in some smooth way
				for (let i = 2; i < face.indices.length; ++i) {
					triangle(
						cell.vertices[face.indices[0]], cell.vertices[face.indices[i-1]], cell.vertices[face.indices[i]],
						css2Uint32(face.color));
					
				}
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}
const visBody = new VisBody();
const visTemplateBody = new VisBody();
window.visBody = visBody; //DEBUG

//compute cell center point, face centers, and port vertices (used for drawing stuff):
function setCellDrawingInfo(cell) {
	{ //set center:
		let center = gm.vec3(0.0);
		for (let v of cell.vertices) {
			center = gm.add(center, v);
		}
		center = gm.scale(1.0 / cell.vertices.length, center);
		cell.center = center;
	}

	let ports = [];
	let centers = [];
	for (const face of cell.template.faces) {
		let center = gm.vec3(0.0);
		for (let vi of face.indices) {
			center = gm.add(center, cell.vertices[vi]);
		}
		center = gm.scale(1.0 / face.indices.length, center);
		centers.push(center);

		let port = [];
		for (let i = 0; i < face.indices.length; ++i) {
			let v = cell.vertices[face.indices[i]];
			v = gm.mix(v, center, 0.5); //move toward center of face
			port.push(v);
		}
		ports.push(port);
	}
	cell.ports = ports;
	cell.centers = centers;
}

function deleteCellDrawingInfo(cell) {
	delete cell.center;
	delete cell.ports;
	delete cell.centers;
}

class VisWire extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisWire.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisWire.BYTES_PER_ATTRIB;

		const SHOW_INTERNAL_FACES = false;
		const SHOW_TIGHT_CONNECTIONS = false;
		const SHOW_MISSING_CONNECTIONS = true;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				totalAttribs += face.indices.length * 2 + 4;
				const con = cell.connections[fi];
				if (con !== null) totalAttribs += face.indices.length * 3;
				else if (face.type !== 'x') totalAttribs += face.indices.length * 2;
			}
			for (const yarn of cell.template.yarns) {
				totalAttribs += (yarn.pts.length-1)*2;
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		for (const cell of body.cells) {
			setCellDrawingInfo(cell);
		}

		for (const cell of body.cells) {
			//yarns:
			const xf = cell.xform;
			for (const yarn of cell.template.yarns) {
				let prev = null;
				let col = rgb2Uint32([1.0, 0.6, 0.5]);
				for (const pt of yarn.pts) {
					let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
					if (prev !== null) {
						attrib(prev[0],prev[1],prev[2], col);
						attrib(at[0],at[1],at[2], col);
					}
					prev = at;
				}
			}

			//faces:
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				if (!SHOW_INTERNAL_FACES) {
					//skip faces which are connected tightly:
					const connection = cell.connections[fi];
					if (connection !== null) {
						const ofs = gm.sub(connection.cell.centers[connection.face], cell.centers[fi]);
						const length2 = gm.dot(ofs,ofs);
						if (length2 < 0.1 * 0.1) {
							continue;
						}
					}
				}
				const face = cell.template.faces[fi];
				const center = cell.centers[fi];
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32(face.color);
					attrib(a[0],a[1],a[2], col);
					attrib(b[0],b[1],b[2], col);
					if (i === 0 && face.type !== 'x') { //show "first edge" (for non-'x' face types)
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						attrib(a[0],a[1],a[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(b[0],b[1],b[2], col);
					}
				}
			}

			//connections:
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) {
					if (cell.template.faces[fi].type[0] !== 'x' && SHOW_MISSING_CONNECTIONS) {
						const col = (cell.template.faces[fi].type[0] === '+' ? COLOR_OUTPUT_WARNING : COLOR_INPUT_WARNING);
						for (let i = 0; i < cell.ports[fi].length; ++i) {
							let a = cell.ports[fi][i];
							let ca = gm.mix(a, cell.center, 0.1);
							attrib(ca[0], ca[1], ca[2], col); attrib(a[0], a[1], a[2], col);
						}
					}
					continue;
				}
				if (cell.template.faces[fi].type[0] !== '+') continue; //draw connectsions from '+' => '-'

				let maxLength2 = 0;
				const watermark = dataOffset;
				sv.forAlignedIndices(cell.template.faces[fi], connection.cell.template.faces[connection.face], (i, ci) => {
					let colOut = COLOR_OUTPUT;
					let colIn = COLOR_INPUT;
					if (!sv.canConnectFaces(cell.template.faces[fi], connection.cell.template.faces[connection.face])) {
						//apparently somehow this connection got made though it shouldn't be allowed:
						colOut = COLOR_OUTPUT_WARNING;
						colIn = COLOR_INPUT_WARNING;
					}
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attrib(ca[0], ca[1], ca[2], colOut); attrib(a[0], a[1], a[2], colOut);
					attrib(a[0], a[1], a[2], colOut); attrib(b[0], b[1], b[2], colIn);
					attrib(b[0], b[1], b[2], colIn); attrib(cb[0], cb[1], cb[2], colIn);

					if (!SHOW_TIGHT_CONNECTIONS) {
						const ofs = gm.sub(b,a);
						const length2 = gm.dot(ofs,ofs);
						maxLength2 = Math.max(maxLength2, length2);
					}
				} );

				if (!SHOW_TIGHT_CONNECTIONS) {
					if (maxLength2 < 0.01 * 0.01) {
						dataOffset = watermark;
					}
				}
			}
		}

		
		//remove temp stuff:
		for (const cell of body.cells) {
			deleteCellDrawingInfo(cell);
		}


		//with various skipping may actually under-fill:
		console.assert(dataOffset <= arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = dataOffset / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}

const visWire = new VisWire();
const visTemplateWire = new VisWire();
window.visWire = visWire; //DEBUG


class VisWireCells extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor(respectVisibility=true) {
		const BYTES_PER_ATTRIB = VisWireCells.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer; //needed for set()
		this.respectVisibility = respectVisibility;
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisWireCells.BYTES_PER_ATTRIB;

		const SHOW_INTERNAL_FACES = false;
		const SHOW_TIGHT_CONNECTIONS = false;
		const SHOW_MISSING_CONNECTIONS = true;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			if (this.respectVisibility && (!checkCellVisible(cell))) continue;
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				totalAttribs += face.indices.length * 2 + 4;
				const con = cell.connections[fi];
				if (con !== null) totalAttribs += face.indices.length * 3;
				else if (face.type !== 'x') totalAttribs += face.indices.length * 2;
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		for (const cell of body.cells) {
			setCellDrawingInfo(cell);
		}

		for (const cell of body.cells) {
			if (this.respectVisibility && (!checkCellVisible(cell))) continue;
			//faces:
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				if (!SHOW_INTERNAL_FACES) {
					//skip faces which are connected tightly:
					const connection = cell.connections[fi];
					if (connection !== null) {
						const ofs = gm.sub(connection.cell.centers[connection.face], cell.centers[fi]);
						const length2 = gm.dot(ofs,ofs);
						if (length2 < 0.1 * 0.1) {
							continue;
						}
					}
				}
				const face = cell.template.faces[fi];
				const center = cell.centers[fi];
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32(face.color);
					attrib(a[0],a[1],a[2], col);
					attrib(b[0],b[1],b[2], col);
					if (i === 0 && face.type !== 'x') { //show "first edge" (for non-'x' face types)
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						attrib(a[0],a[1],a[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(b[0],b[1],b[2], col);
					}
				}
			}

			//connections:
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) {
					if (cell.template.faces[fi].type[0] !== 'x' && SHOW_MISSING_CONNECTIONS) {
						const col = (cell.template.faces[fi].type[0] === '+' ? COLOR_OUTPUT_WARNING : COLOR_INPUT_WARNING);
						for (let i = 0; i < cell.ports[fi].length; ++i) {
							let a = cell.ports[fi][i];
							let ca = gm.mix(a, cell.center, 0.1);
							attrib(ca[0], ca[1], ca[2], col); attrib(a[0], a[1], a[2], col);
						}
					}
					continue;
				}
				if (cell.template.faces[fi].type[0] !== '+') continue; //draw connectsions from '+' => '-'

				let maxLength2 = 0;
				const watermark = dataOffset;
				sv.forAlignedIndices(cell.template.faces[fi], connection.cell.template.faces[connection.face], (i, ci) => {
					let colOut = COLOR_OUTPUT;
					let colIn = COLOR_INPUT;
					if (!sv.canConnectFaces(cell.template.faces[fi], connection.cell.template.faces[connection.face])) {
						//apparently somehow this connection got made though it shouldn't be allowed:
						colOut = COLOR_OUTPUT_WARNING;
						colIn = COLOR_INPUT_WARNING;
					}
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attrib(ca[0], ca[1], ca[2], colOut); attrib(a[0], a[1], a[2], colOut);
					attrib(a[0], a[1], a[2], colOut); attrib(b[0], b[1], b[2], colIn);
					attrib(b[0], b[1], b[2], colIn); attrib(cb[0], cb[1], cb[2], colIn);

					if (!SHOW_TIGHT_CONNECTIONS) {
						const ofs = gm.sub(b,a);
						const length2 = gm.dot(ofs,ofs);
						maxLength2 = Math.max(maxLength2, length2);
					}
				} );

				if (!SHOW_TIGHT_CONNECTIONS) {
					if (maxLength2 < 0.01 * 0.01) {
						dataOffset = watermark;
					}
				}
			}
		}

		
		//remove temp stuff:
		for (const cell of body.cells) {
			deleteCellDrawingInfo(cell);
		}


		//with various skipping may actually under-fill:
		console.assert(dataOffset <= arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = dataOffset / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}

const visWireCells = new VisWireCells(false);
const visTemplateWireCells = new VisWireCells(false);
window.visWireCells = visWireCells; //DEBUG


class VisTubes extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 4*3 + 4*2 + 4*1 + 4*1; //Position, Normal, UV, Color, CellID
	constructor(solid=true, fixedVisibility=null) {
		const BYTES_PER_ATTRIB = VisTubes.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3},
			UV:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3},
			CellID:{buffer:buffer, size:1, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3 + 4*2},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3 + 4*2 + 4*1},
		};

		super(gl, attribs, gl.TRIANGLES, 0);

		this.buffer = buffer; //needed for set()
		this.resolution = 6;
		this.radius = 0.08;
		this.solid = solid;
		this.col_rgb = [1.0, 0.6, 0.5];
		this.col_transparent = rgba2Uint32([...this.col_rgb, 0.1]);
		this.col_opaque = rgb2Uint32(this.col_rgb);
		this.selectedColor = [1.0, 0.4, 0.3, 1.0];
		this.fixedVisibility = fixedVisibility;
		this.empty = false;
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisTubes.BYTES_PER_ATTRIB;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			if (this.fixedVisibility === false || (this.fixedVisibility == null && checkCellVisible(cell) !== this.solid)) continue;
			for (const yarn of cell.template.yarns) {
				totalAttribs += (yarn.pts.length-1) * 6 * this.resolution;
			}
		}
		this.empty = (totalAttribs === 0);

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, nx,ny,nz, u,v, rgba, id) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, nx, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, ny, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, nz, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, 2.*u, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, 2.*v, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, id, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		function triangle(va,vb,vc, na,nb,nc, uva,uvb,uvc, color, id) {
			let shadeSmooth = true;
			if (!shadeSmooth) {
				let n = gm.normalize(gm.cross(gm.sub(vb, va), gm.sub(vc, va)));
				na = n; nb = n; nc = n;
			}

			attrib(va[0],va[1],va[2], na[0],na[1],na[2], uva[0], uva[1], color, id);
			attrib(vb[0],vb[1],vb[2], nb[0],nb[1],nb[2], uvb[0], uvb[1], color, id);
			attrib(vc[0],vc[1],vc[2], nc[0],nc[1],nc[2], uvc[0], uvc[1], color, id);
		}

		function quad(a, na, uva, b, nb, uvb, c, nc, uvc, d, nd, uvd, color, id) {
			// triangulate by shortest diagonal
			const lac = gm.length2(gm.sub(c, a));
			const lbd = gm.length2(gm.sub(b, d));

			if (lac < lbd) {
				triangle(a, b, c, na, nb, nc, uva, uvb, uvc, color, id);
				triangle(a, c, d, na, nc, nd, uva, uvc, uvd, color, id);
			} else {
				triangle(a, b, d, na, nb, nd, uva, uvb, uvd, color, id);
				triangle(b, c, d, nb, nc, nd, uvb, uvc, uvd, color, id);
			}

		}

		function snapAxisAligned(T) {
			if (T[0] > 0.5) {
				return gm.vec3(1,0,0);
			} else if (T[0] < -0.5) {
				return gm.vec3(-1, 0, 0);
			} else if (T[1] > 0.5) {
				return gm.vec3(0, 1, 0);
			} else if (T[1] < -0.5) {
				return gm.vec3(0, -1, 0);
			} else if (T[2] > 0.5) {
				return gm.vec3(0, 0, 1);
			} else {
				return gm.vec3(0, 0, -1);
			}
		}

		for (const cell of body.cells) {
			setCellDrawingInfo(cell);
		}

		function snappedFrame(T) {
			if (Math.abs(T[0]) > 0.9) {
				return {x: gm.vec3(0, T[0], 0), y: gm.vec3(0, 0, 1)};
			} else if (Math.abs(T[1]) > 0.9) {
				return {x: gm.vec3(0, 0, T[1]), y: gm.vec3(1, 0, 0)};
			} else {
				return {x: gm.vec3(T[2], 0, 0), y: gm.vec3(0, 1, 0)};
			}
		}

		for (let cellID = 0; cellID < body.cells.length; ++cellID) {
			const cell = body.cells[cellID];
			if (this.fixedVisibility === false || (this.fixedVisibility == null && checkCellVisible(cell) !== this.solid)) continue;

			const col = this.solid ? this.col_opaque : this.col_transparent;

			//yarns:
			const xf = cell.xform;
			for (const yarn of cell.template.yarns) {
				const generate_uv = yarn["oriented"];

				// define frame
				let frames = [];
				let prev, at, Tprev;
				let yarnLength = 0;
				for (let iP = 0; iP < yarn.pts.length; iP++) {
					if (iP == 0) { // special case for first point
						at = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP], 1]);
						const next = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP+1], 1]);
						Tprev = snapAxisAligned(gm.normalize(gm.sub(next,at))); // tangent vector along first edge
						frames.push(snappedFrame(Tprev));
						prev = at;
						at = next;
					} else if (iP + 1 == yarn.pts.length) { // special case for last point
						const Tnext = snapAxisAligned(gm.normalize(gm.sub(at, prev))); // tangent vector along last edge
						frames.push(snappedFrame(Tnext));
						yarnLength += gm.dist(prev, at);
					} else {
						const next = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP+1], 1]);
						const Tnext = gm.normalize(gm.sub(next, at)); // tangent vector along prev edge
						const T = gm.normalize(gm.add(Tprev, Tnext));

						// pick a starting direction for polygon. arbitrarily pick z axis, unless vector points mostly in z direction, then pick x axis
						let axis = (Math.abs(T[2]) < 0.7) ? gm.vec3(0, 0, 1) : gm.vec3(1, 0, 0);

						// find x and y directions at prev and at points by projecting axis onto orthogonal complement of vertex tangent vector, and taking 90 degree rotation
						let x = gm.normalize(gm.sub(axis, gm.scalarmul(gm.dot(axis, T),T)));
						let y = gm.cross(Tprev, x);

						frames.push({x: x, y: y});
						yarnLength += gm.dist(prev, at);
						prev = at;
						at = next;
						Tprev = Tnext;
					}
				}

				// scale length to nearest integer
				// TODO: pick a good length scale
				const roundLength = Math.round(yarnLength);
				const uScale = roundLength / yarnLength;

				// generate cylinder
				let x_prev, y_prev; // and still using prev
				let u = 0;
				let v_offset = 0;
				for (let iP = 1; iP < yarn.pts.length; iP++) {
					if (iP == 1) {
						prev = gm.mul_mat4x3_vec4(xf, [...yarn.pts[0], 1]);
						x_prev = frames[0].x;
						y_prev = frames[0].y;
					}
					const at = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP], 1]);
					const x_at = frames[iP].x;
					const y_at = frames[iP].y;
					const cs = gm.dot(x_prev, x_at);
					const sn = gm.dot(gm.normalize(gm.sub(at, prev)), gm.cross(x_at, x_prev));
					const twist = Math.atan2(sn, cs) / (2 * Math.PI);
					const offset = Math.round(twist * this.resolution) / this.resolution;
					const angleShift = (twist - offset);
					const du = gm.length(gm.sub(prev, at)) * uScale;

					// finally emit cylinder by drawing circles in x-y planes and connecting them by quads
					let pj_prev, pj_at, uvj_prev, uvj_at;
					for (let i=0; i<this.resolution; i++) {
						if (i==0) {
							const tj_prev = -1. / this.resolution;
							const tj_at = tj_prev + offset;
							uvj_prev = generate_uv ? gm.vec2(u, tj_prev + v_offset) : gm.vec2(0, 0);
							uvj_at = generate_uv ? gm.vec2(u+du, tj_prev - angleShift + v_offset) : gm.vec2(0, 0);

							pj_prev = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * tj_prev), x_prev),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * tj_prev), y_prev));
							pj_at = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * tj_at), x_at),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * tj_at), y_at));
						}
						const ti_prev = (i / this.resolution);
						const ti_at = ti_prev + offset;
						const uvi_prev = generate_uv ? gm.vec2(u, ti_prev + v_offset) : gm.vec2(0, 0);
						const uvi_at = generate_uv ? gm.vec2(u+du, ti_prev - angleShift + v_offset) : gm.vec2(0, 0);

						const pi_prev = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * ti_prev), x_prev),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * ti_prev), y_prev));
						const pi_at = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * ti_at), x_at),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * ti_at), y_at));
						quad(gm.add(prev, pi_prev), pi_prev, uvi_prev, gm.add(at, pi_at), pi_at, uvi_at, gm.add(at, pj_at), pj_at, uvj_at, gm.add(prev, pj_prev), pj_prev, uvj_prev, col, cellID);
						pj_prev = pi_prev; pj_at = pi_at; uvj_prev = uvi_prev; uvj_at = uvi_at;
					}

					u += du;
					v_offset -= offset + angleShift;
					prev = at;
					x_prev = x_at;
					y_prev = y_at;
				}
			}
		}

		
		//remove temp stuff:
		for (const cell of body.cells) {
			deleteCellDrawingInfo(cell);
		}


		//with various skipping may actually under-fill:
		console.assert(dataOffset <= arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = dataOffset / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}

const visTubes = new VisTubes(true);
const visTransparentTubes = new VisTubes(false);
const visTemplateTubes = new VisTubes(true, true /* always solid */);
window.visTubes = visTubes; //DEBUG
window.visTransparentTubes = visTransparentTubes; //DEBUG
window.visTemplateTubes = visTemplateTubes; //DEBUG
const visPreviewTubes = new VisTubes(true, true /* always opaque */);
visPreviewTubes.col_rgb = [0.8, 0.6, 1.0];
visPreviewTubes.col_opaque = rgb2Uint32(visPreviewTubes.col_rgb);
// visPreviewTubes.col_transparent = rgba2Uint32([...visPreviewTubes.col_rgb, 0.1]);
// visPreviewTubes.col_rgb = rgba2Uint32([...visPreviewTubes.col_rgb, 0.5]); // increase opacity

class VisPreviewLines extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisPreviewLines.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer;
	}
	update() {
		const BYTES_PER_ATTRIB = VisPreviewLines.BYTES_PER_ATTRIB;

		let attribs = []; //x,y,z,color

		function line(a,b,color) {
			attribs.push(a[0],a[1],a[2],color);
			attribs.push(b[0],b[1],b[2],color);
		}

		//----- make debug/UI lines ----
		
		// cursor:
		if (CURSOR.x === CURSOR.x) {
			const ray = mouseRay();
			let r = camera.computeRight();
			let u = camera.computeUp();
			r = gm.scale(0.01, r);
			u = gm.scale(0.01, u);
			const c = gm.add(ray.origin, ray.direction);
			line(gm.add(c,r), gm.sub(c,r), 0xffff00ff);
			line(gm.add(c,u), gm.sub(c,u), 0xffff00ff);
		}

		//currently hovered face:
		if (CURSOR.over !== null) {
			const cell = CURSOR.over.cell;
			const face = cell.template.faces[CURSOR.over.face];
			for (let i = 0; i < face.indices.length; ++i) {
				line(cell.vertices[face.indices[(i == 0 ? face.indices.length : i) - 1]], cell.vertices[face.indices[i]], 0xffff0088);
			}
		}

		//currently hovered grid cell:
		if (CURSOR.grid !== null) {
			const x = Math.floor(CURSOR.grid.x);
			const y = Math.floor(CURSOR.grid.y);

			line([x, y, 0], [x+1,y,0], 0xff00ffff);
			line([x+1,y, 0], [x+1,y+1,0], 0xff00ffff);
			line([x+1, y+1, 0], [x,y+1,0], 0xff00ffff);
			line([x,y+1,0], [x,y,0], 0xff00ffff);
		}

		//preview cell addition:
		const cell = previewCell();
		if (cell !== null) {
			setCellDrawingInfo(cell);

			//yarns:
			// const xf = cell.xform;
			// for (const yarn of cell.template.yarns) {
			// 	let prev = null;
			// 	let col = rgb2Uint32([1.0, 0.6, 0.5]);
			// 	for (const pt of yarn.pts) {
			// 		let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
			// 		if (prev !== null) {
			// 			line(prev,at, col);
			// 		}
			// 		prev = at;
			// 	}
			// }

			//faces:
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				const center = cell.centers[fi];
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32(face.color);
					line(a,b,col);
					if (i === 0 && face.type !== 'x') { //decorate first edge
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						line(a,c,col);
						line(c,b,col);
					}
				}
			}

			//compute drawing info for all connected cells:
			for (const connection of cell.connections) {
				if (connection !== null) setCellDrawingInfo(connection.cell);
			}

			//connections:
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) {
					if (cell.template.faces[fi].type !== 'x') {
						const col = (cell.template.faces[fi].type[0] === '+' ? COLOR_OUTPUT_WARNING : COLOR_INPUT_WARNING);
						for (let i = 0; i < cell.ports[fi].length; ++i) {
							let a = cell.ports[fi][i];
							let ca = gm.mix(a, cell.center, 0.1);
							line(ca, a, col);
						}
					}
					continue;
				}

				sv.forAlignedIndices(cell.template.faces[fi], connection.cell.template.faces[connection.face], (i, ci) => {
					let colOut = COLOR_OUTPUT;
					let colIn = COLOR_INPUT;
					if (cell.template.faces[fi].type[0] === '-') {
						[colOut, colIn] = [colIn, colOut];
					}
					if (!sv.canConnectFaces(cell.template.faces[fi], connection.cell.template.faces[connection.face])) {
						//apparently somehow this connection got made though it shouldn't be allowed:
						colOut = COLOR_OUTPUT_WARNING;
						colIn = COLOR_INPUT_WARNING;
					}
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attribs.push(ca[0], ca[1], ca[2], colOut); attribs.push(a[0], a[1], a[2], colOut);
					attribs.push(a[0], a[1], a[2], colOut); attribs.push(b[0], b[1], b[2], colIn);
					attribs.push(b[0], b[1], b[2], colIn); attribs.push(cb[0], cb[1], cb[2], colIn);
				} );
			}

			//remove temp drawing info:
			for (const connection of cell.connections) {
				if (connection !== null) deleteCellDrawingInfo(connection.cell);
			}

		}

		//---- copy debug lines to buffer for drawing ----

		//copy attribs to a formatted buffer:
		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * (attribs.length / 4));
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		for (let i = 0; i < attribs.length; i += 4) {
			data.setFloat32(dataOffset, attribs[i+0], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+1], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+2], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, attribs[i+3], false); dataOffset += 4;
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STREAM_DRAW);
	}
}
const visPreviewLines = new VisPreviewLines();

let yarnVisMode = "Tube";
function setYarnVisMode(mode) {
	if (mode == "Wire") {
		yarnVisMode = "Wire";
	} else if (mode == "Body") {
		yarnVisMode = "Body";
	} else if (mode == "Tube") {
		yarnVisMode = "Tube";
	} else {
		console.log("Error, invalid vis mode ", mode);
	}
	bodyDirty();
	requestRedraw()
}

function setViewMode(mode) {
	const patternButton = document.getElementById("3dview-set-pattern-mode");
	const templateButton = document.getElementById("3dview-set-template-mode");
	// clear current mode
	patternButton.classList.remove("active");
	templateButton.classList.remove("active");

	if (mode == "Pattern") {
		patternButton.classList.add("active");
		viewMode = ViewMode.Pattern;
		bodyDirty();
	} else if (mode == "Template") {
		templateButton.classList.add("active");
		viewMode = ViewMode.Template;
		templateDirty();
	} else {
		console.log("Error, invalid view mode ", mode);
	}
	requestRedraw()
}

function setSidebar(mode) {
	const designButton = document.getElementById("sidebar-set-design-mode");
	const codegenButton = document.getElementById("sidebar-set-codegen-mode");
	const library = document.getElementById("library");
	const knitout = document.getElementById("view-knitout");
	const blockData = document.getElementById("view-block-data");
	const commands = document.getElementById("view-shortcuts");

	// clear current mode
	designButton.classList.remove("active");
	codegenButton.classList.remove("active");
	library.style.display="none";
	knitout.style.display="none";
	blockData.style.display="none";
	commands.style.display = "none";

	if (mode == "PatternDesign") {
		library.style.display="grid";
		knitout.style.display="none";
		blockData.style.display="none";
		commands.style.display = "grid";
		designButton.classList.add("active");
	} else if (mode == "CodeGen") {
		library.style.display="none";
		knitout.style.display="grid";
		blockData.style.display="grid";
		commands.style.display = "none";
		codegenButton.classList.add("active");
	} else {
		console.log("Error, invalid sidebar mode ", mode);
	}
}

// set up response to clicking on visualization options
document.getElementById("select-yarn-vis-option").addEventListener("change", function() {setYarnVisMode(this.value);});
setYarnVisMode(document.getElementById("select-yarn-vis-option").value);

for (const elem of document.getElementById('layer-visibility-form').children) {
	elem.addEventListener('click', function() {bodyDirty();});
}

for (const elem of document.getElementById('show-yarn-direction-form').children) {
	elem.addEventListener('click', function() {bodyDirty();});
}

// document.getElementById("select-viewmode-option").addEventListener("change", function() {setViewMode(this.value);});
// setViewMode(document.getElementById("select-viewmode-option").value);
document.getElementById("select-3dview-mode").addEventListener("change", function(e) {setViewMode(e.target.value);});
// set sidebar to current selection
for (let child of document.getElementById("select-3dview-mode").children) {
	if (child.checked) {
		setViewMode(child.value);
		break;
	}
}

document.getElementById("select-sidebar-mode").addEventListener("change", function(e) {setSidebar(e.target.value);});
// set sidebar to current selection
for (let child of document.getElementById("select-sidebar-mode").children) {
	if (child.checked) {
		setSidebar(child.value);
		break;
	}
}

function setDarkMode(setDark) {
	const body = document.getElementsByTagName("body")[0];
	if (setDark) {
		body.classList.remove("lightmode");
		body.classList.add("darkmode");
	} else {
		body.classList.add("lightmode");
		body.classList.remove("darkmode");
	}
	requestRedraw(); // refresh canvas background
}
document.getElementById("darkmode-checkbox").addEventListener("change", function() {setDarkMode(this.checked);});
setDarkMode(document.getElementById("darkmode-checkbox").checked);

// To change the displayed knitout, set knitoutCode.text to a different value and call knitoutDirty() to request a refresh
const knitoutCode = {text: `;;!solid-knitout-VERSION
;;Machine details 
;;Carriers: 1

; 3x3x3.block solid knitout

; =============================
;          First Layer      
; =============================

; cast on / first row
tuck + hf1,4 1
tuck + hf2,4 1
tuck + hf3,4 1

roll hf*,9 hb*,9
pause Please set up caston on machine

knit b3 hf3,4 1
knit b2 hf2,4 1
knit b1 hf1,4 1

release f

; second row
tuck + hf1,5 1    ; block 1
xfer b1 hf1,5     ; block 1
knit b1 hf1,5 1 ; block 1

tuck + hf2,5 1    ; block 2
xfer b2 hf2,5     ; block 2
knit b2 hf2,5 1 ; block 2

tuck + hf3,5 1    ; block 3
xfer b3 hf3,5     ; block 3
knit b3 hf3,5 1 ; block 3

release f

; third row
tuck - hf3,6 1
xfer b3 hf3,6
knit b3 hf3,6 1

tuck - hf2,6 1
xfer b2 hf2,6
knit b2 hf2,6 1

tuck - hf1,6 1
xfer b1 hf1,6
knit b1 hf1,6 1

release f

; xfer the final row

xfer b1 hf1,7
xfer b2 hf2,7
xfer b3 hf3,7

; =============================
;          Second Layer      
; =============================

xfer hf1,7 f1
xfer hf2,7 f2
xfer hf3,7 f3

; first row
tuck + hb1,4 1
xfer f1 hb1,4 
xfer hf1,6 f1
knit f1 hb1,4 1

tuck + hb2,4 1
xfer f2 hb2,4
xfer hf2,6 f2
knit f2 hb2,4 1

tuck + hb3,4 1
xfer f3 hb3,4 
xfer hf3,6 f3
knit f3 hb3,4 1

release b

; second row
tuck - hb3,5 1
xfer f3 hb3,5
xfer hf3,5 f3
knit f3 hb3,5 1

tuck - hb2,5 1
xfer f2 hb2,5
xfer hf2,5 f2
knit f2 hb2,5 1

tuck - hb1,5 1
xfer f1 hb1,5
xfer hf1,5 f1
knit f1 hb1,5 1

release b

; third row
tuck + hb1,6 1
xfer f1 hb1,6 
xfer hf1,4 f1
knit f1 hb1,6 1

tuck + hb2,6 1
xfer f2 hb2,6 
xfer hf2,4 f2
knit f2 hb2,6 1

tuck + hb3,6 1
xfer f3 hb3,6
xfer hf3,4 f3
knit f3 hb3,6 1

release b

;xfer the final row
xfer f3 hb3,7
xfer f2 hb2,7
xfer f1 hb1,7


; ============================
;          Third Layer      
; ============================

xfer hb3,7 b3
xfer hb2,7 b2
xfer hb1,7 b1

; first row
tuck - hf3,4 1
xfer b3 hf3,4 
xfer hb3,6 b3
knit b3 hf3,4 1

tuck - hf2,4 1
xfer b2 hf2,4 
xfer hb2,6 b2
knit b2 hf2,4 1

tuck - hf1,4 1
xfer b1 hf1,4 
xfer hb1,6 b1
knit b1 hf1,4 1

release f

; second row
tuck + hf1,5 1
xfer b1 hf1,5 
xfer hb1,5 b1
knit b1 hf1,5 1

tuck + hf2,5 1
xfer b2 hf2,5 
xfer hb3,5 b3
knit b2 hf2,5 1

tuck + hf3,5 1
xfer b3 hf3,5 
xfer hb2,5 b2
knit b3 hf3,5 1

release f

; third row
tuck - hf3,6 1
xfer b3 hf3,6 
xfer hb3,4 b3
knit b3 hf3,6 1

tuck - hf2,6 1
xfer b2 hf2,6 
xfer hb2,4 b2
knit b2 hf2,6 1

tuck - hf1,6 1
xfer b1 hf1,6 
xfer hb1,4 b1
knit b1 hf1,6 1

release f

;; xfer the final row

xfer b1 hf1,7 
xfer b2 hf2,7 
xfer b3 hf3,7

roll hf*,9 hb*,9
pause Please bind off the final row` };


const groupKnitoutPassesCheckbox = document.getElementById('group-knitout-passes-form').children[1];
writeHighlightedCode(knitoutCode.text, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
groupKnitoutPassesCheckbox.addEventListener('click', function() {
	writeHighlightedCode(knitoutCode.text, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
});

function displayHoveredBlockInfo(over) {
	const infoArea = document.getElementById("hovered-block-info");
	infoArea.innerHTML = "";

	let posString, embString, id, ports, longname, schedulingData;
	if (over != null) {
		id = over.cellID;
		ports = over.cell.template.signature().substr(over.cell.template.name.length + 1);
		longname = over.cell.template.longname;
		const pos = gm.xformTranslation(over.cell.xform); // TODO: shift cube coordinates to be integer?
		posString = "( " + pos[0].toFixed(2) + ", " + pos[1].toFixed(2) + ", " + pos[2].toFixed(2) + " )";
		schedulingData = over.cell.schedulingData ? over.cell.schedulingData : {};


		if (over.cell.schedulingData && over.cell.schedulingData.embedding) {
			const emb = over.cell.schedulingData.embedding;
			embString = "( " + emb[0].toFixed(2) + ", " + emb[1].toFixed(2) + ", " + emb[2].toFixed(2) + " )";	
		}
	} else {
		id = null;
		ports = null;
		longname = null;
		posString = null;
		schedulingData = {};
	}

	const displayData = function(name, value, variableName) {
		const nameElem = document.createElement('label');
		nameElem.innerHTML = name;
		nameElem.classList.add("field-name");
		nameElem.for = "input-" + name;
		infoArea.appendChild(nameElem);
		const valueElem = document.createElement('div');
		valueElem.classList.add("field-value");
		if (variableName == null) {
			valueElem.innerHTML = value == null ? "&nbsp;" : value; // print space to set line height
		} else {
			const textInput = document.createElement('input');
			textInput.type = "text";
			textInput.id = "input-"+name;
			textInput.name = name;
			textInput.value = value == null ? "" : value; // print space to set line height
			if (over == null) {
				textInput.disabled = true;
			} else {
				textInput.onchange = function() {
					pushCommand({type: "editSchedulingData", cell: over.cell, field: variableName, oldValue: over.cell.schedulingData[variableName], newValue: textInput.value});
					over.cell.schedulingData[variableName] = textInput.value;
				};
			}
			valueElem.appendChild(textInput);
		}
		infoArea.appendChild(valueElem);
	};
	
	displayData("ID", id);
	displayData("Long Name", longname);
	displayData("Ports", ports);
	displayData("Position", posString);
	displayData("Embedding", embString);
	displayData("Bed", schedulingData.bed, "bed");
	displayData("Nx", schedulingData.Nx, "Nx");
	displayData("HFxy", schedulingData.HFxy, "HFxy");
	displayData("HBxy", schedulingData.HBxy, "HBxy");
	displayData("D", schedulingData.D, "D");
	displayData("CS", schedulingData.CS, "CS");
	displayData("Layer", schedulingData.layer, "layer");
}

const postprocessProgram = new Program(gl,
`
	attribute vec2 Position;
	attribute vec2 TexCoord;
	varying vec2 texCoord;
	void main() {
		gl_Position = vec4(Position,0,1);
		texCoord = TexCoord;
	}
`,`
	uniform sampler2D DEPTH_SHADED_TEX;
	uniform sampler2D DEPTH_SHADED_DEPTH;
	uniform sampler2D NON_DEPTH_SHADED_TEX;
	uniform sampler2D NON_DEPTH_SHADED_DEPTH;
	uniform highp vec2 PX;
	varying highp vec2 texCoord;
	void main() {
		//gl_FragColor = vec4(1,0,1,1);
		//gl_FragColor = vec4(texCoord,1,1);
		//gl_FragColor = texture2D(DEPTH_SHADED_TEX, gl_FragCoord.xy/1000.0);
		//gl_FragColor = vec4(texture2D(DEPTH_SHADED_TEX, texCoord).r, texCoord, 1);
		mediump vec3 depth_shaded_color = texture2D(DEPTH_SHADED_TEX, texCoord).rgb;
		mediump vec3 non_depth_shaded_color = texture2D(NON_DEPTH_SHADED_TEX, texCoord).rgb;
		mediump float depth_shaded_depth = texture2D(DEPTH_SHADED_DEPTH, texCoord).r;
		mediump float non_depth_shaded_depth = texture2D(NON_DEPTH_SHADED_DEPTH, texCoord).r;

		//this is taken from autoknit:
		highp float ref = texture2D(DEPTH_SHADED_DEPTH, texCoord).r;
		highp float z = min(0.9999, ref);
		//over from depth component space -> projected z value:
		z = 2.0 * (z - 0.5);
		//from projected z value to world z value:
		#define NEAR 0.1
		z = (2.0 * NEAR) / (z - 1.0);
		//z is now in range [-inf, -NEAR]
		z += 0.5; //depth offset for maximum shade
		//back to projected space:
		z = 1.0 + (2.0 * NEAR) / z;
		z = 0.5 * z + 0.5;
		highp float amt = 1.0 / (z - ref);

		#define DO(X,Y) { \
			lowp float val = texture2D(DEPTH_SHADED_DEPTH, texCoord+vec2(X,Y)*PX*1.5).r; \
			tint += clamp((val - ref) * amt, 0.0, 1.0); \
		}

		#define R 3
		highp float tint = 0.0;
		mediump float w = 0.;
		for (int dy = -R; dy <= R; dy++) {
			for (int dx = -R; dx <= R; dx++) {
				if (!(dx == 0 && dy == 0)) {
					DO(dx, dy);
					w += 1.;
				}
			}
		}    
		tint = 1.0 - (tint / w);
		depth_shaded_color *= tint;
		gl_FragColor = depth_shaded_depth < non_depth_shaded_depth ? vec4(depth_shaded_color, 1) : vec4(non_depth_shaded_color, 1);
		// gl_FragColor = vec4(depth_shaded_color, 1);
	}
`);
window.postprocessProgram = postprocessProgram;


//Because lack of gl_VertexID in WEBGL1's GLSL means we can't do the lazy fullscreen-triangle-generated-by-vertex-shader trick:
class FullscreenTriangle extends Geometry {
	constructor() {
		const buffer = gl.createBuffer();
		const attribs = {
			Position:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:4*4, offset:0},
			TexCoord:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:4*4, offset:2*4}
		};
		super(gl, attribs, gl.TRIANGLES, 0);
		let data = new Float32Array([ -1,-1, 0,0,   3,-1, 2,0,  -1,3, 0,2 ]);
		this.buffer = buffer;
		this.count = 3;
		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	}
}
const fullscreenTriangle = new FullscreenTriangle();
window.fullscreenTriangle = fullscreenTriangle; //DEBUG

class Postprocess {
	constructor() {
		this.w = 0;
		this.h = 0;
		if (ext_WEBGL_depth_texture) {
			console.log("Postprocessing enabled.");
			this.enabled = true;
		} else {
			console.log("Don't have WEBGL_depth_texture; postprocessing disabled.");
			this.enabled = false;
		}
	}
	resize(w,h) {
		if (!this.enabled) return;
		if (w === this.w && h === this.h) return;
		this.w = w;
		this.h = h;

		if (!('depth_shaded_depth_tex' in this)) this.depth_shaded_depth_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_depth_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, w, h, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('depth_shaded_color_tex' in this)) this.depth_shaded_color_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_color_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, w, h, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('depth_shaded_fb' in this)) {
			this.depth_shaded_fb = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.depth_shaded_fb);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.depth_shaded_color_tex, 0);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depth_shaded_depth_tex, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.depth_shaded_fb);
		const depth_shaded_complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (depth_shaded_complete !== gl.FRAMEBUFFER_COMPLETE) {
			console.log(`Failed to resize postprocessing framebuffer: ${depth_shaded_complete}`);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		if (!('non_depth_shaded_depth_tex' in this)) this.non_depth_shaded_depth_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_depth_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, w, h, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('non_depth_shaded_color_tex' in this)) this.non_depth_shaded_color_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_color_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, w, h, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('non_depth_shaded_fb' in this)) {
			this.non_depth_shaded_fb = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.non_depth_shaded_fb);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.non_depth_shaded_color_tex, 0);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.non_depth_shaded_depth_tex, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.non_depth_shaded_fb);
		const non_depth_shaded_complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (non_depth_shaded_complete !== gl.FRAMEBUFFER_COMPLETE) {
			console.log(`Failed to resize postprocessing framebuffer: ${non_depth_shaded_complete}`);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}
	//call before rendering that you want to postprocess:
	begin_depth_shaded() {
		if (!this.enabled) return;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.depth_shaded_fb);
	}
	begin_non_depth_shaded() {
		if (!this.enabled) return;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.non_depth_shaded_fb);
	}
	//call to copy post-processed stuff back to the screen:
	end() {
		if (!this.enabled) return;

		//for DEBUG purposes:
		if (!('check_tex' in this)) {
			this.check_tex = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, this.check_tex);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([
				255,255,255,255,  0,0,0,255,
				0,0,0,255,   255,255,255,255
			]));
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			// gl.bindTexture(gl.TEXTURE_2D, 0);
		}

		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		gl.activeTexture(gl.TEXTURE3);
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_depth_tex);

		gl.activeTexture(gl.TEXTURE2);
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_color_tex);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_depth_tex);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_color_tex);

		gl.useProgram(postprocessProgram.program);
		gl.uniform1i(postprocessProgram.uniformLocations.DEPTH_SHADED_TEX, 0);
		gl.uniform1i(postprocessProgram.uniformLocations.DEPTH_SHADED_DEPTH, 1);
		gl.uniform1i(postprocessProgram.uniformLocations.NON_DEPTH_SHADED_TEX, 2);
		gl.uniform1i(postprocessProgram.uniformLocations.NON_DEPTH_SHADED_DEPTH, 3);
		gl.uniform2f(postprocessProgram.uniformLocations.PX, 1 / canvas.width, 1 / canvas.height);

		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);
		// console.log("drawing");
		gl.clearColor(0.5,0.5,0.5,1.0);
		gl.clear(gl.COLOR_BUFFER_BIT);
		fullscreenTriangle.draw(postprocessProgram);
	}
}
const postprocess = new Postprocess();
window.postprocess = postprocess; //DEBUG

function redrawPatternNonDepthShaded(pixelRatio) {
	visPreviewLines.update();

	//update status line:
	{
		let info = "";
		if (template !== null) {
			info += `Template: ${template.longsignature()}`;
		} else {
			info += `No Template`;
		}
		if (CURSOR.over) {
			info += `; Hovered: ${CURSOR.over.cell.template.longsignature()} / face: ${CURSOR.over.face} (${CURSOR.over.cell.template.faces[CURSOR.over.face].type})`;
		}
		STATUS_LINE.innerText = info;
	}

	// show info about hovered block in sidebar
	displayHoveredBlockInfo(CURSOR.over);
	// if (body.cells.length > 0) displayHoveredBlockInfo({cellID: 0, cell: body.cells[0]});

	gl.lineWidth(2.0 * pixelRatio);
	visPreviewLines.draw(colorProgram);

	gl.lineWidth(1.0 * pixelRatio);
	grid.draw(colorProgram);

	if (yarnVisMode == "Tube") {
		visWireCells.draw(colorProgram);

		// also draw transparent tubes here, since we need to disable depth testing
		if (visTubes.dirty) {
			visTubes.set(body);
			visTransparentTubes.set(body);
			delete visTubes.dirty;
		}

		// draw transparent tubes per https://xem.github.io/articles/webgl-guide-part-2.html#1a
		if (!visTransparentTubes.empty) {
			gl.useProgram(textureProgram.program);
			gl.enable(gl.BLEND);
			gl.blendEquation(gl.FUNC_ADD);
			gl.disable(gl.DEPTH_TEST);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			visTransparentTubes.draw(textureProgram);
			gl.enable(gl.DEPTH_TEST);
			gl.disable(gl.BLEND);
			gl.useProgram(colorProgram.program);
		}
	}

	//show "hidden" debug lines also:

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		0.0, 0.0, 0.0, 0.1
	);
	gl.depthFunc(gl.GREATER);
	gl.depthMask(false);
	gl.lineWidth(2.0 * pixelRatio);
	visPreviewLines.draw(colorProgram);

	gl.depthFunc(gl.LESS);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
}

function redrawPatternDepthShaded(pixelRatio) {

	//update geometry:
	if (yarnVisMode == "Wire" && visWire.dirty) {
		visWire.set(body);
		delete visWire.dirty;
	}
	if (visWireCells.dirty) {
		visWireCells.set(body);
		delete visWireCells.dirty;
	}
	if (yarnVisMode == "Body" && visBody.dirty) {
		visBody.set(body);
		delete visBody.dirty;
	}
	if (yarnVisMode == "Tube" && visTubes.dirty) {
		visTubes.set(body);
		visTransparentTubes.set(body);
		delete visTubes.dirty;
	}
	const cell = previewCell();
	visPreviewTubes.set({cells: (cell ? [cell] : [])});

	
	if (yarnVisMode == "Body") {
		visBody.draw(colorProgram);
	} else if (yarnVisMode == "Wire") {
		visWire.draw(colorProgram);
	} else if (yarnVisMode == "Tube") {
		gl.useProgram(textureProgram.program);
		// draw opaque tubes
		if (!visTubes.empty) visTubes.draw(textureProgram);
		if (!visPreviewTubes.empty) visPreviewTubes.draw(textureProgram);
		gl.useProgram(colorProgram.program);
	}
}

function redrawTemplate(pixelRatio) {
	function getTemplateBody(template) {
		if (template) {
			return {cells: [sv.Cell.fromTemplate(template, gm.identityTransform())]};
		} else {
			return {cells: []};
		}
	}

	// update the geometry
	if (yarnVisMode == "Wire" && visTemplateWire.dirty) {
		visTemplateWire.set(getTemplateBody(template));
		delete visTemplateWire.dirty;
	}
	if (visTemplateWireCells.dirty) {
		visTemplateWireCells.set(getTemplateBody(template));
		delete visTemplateWireCells.dirty;
	}
	if (yarnVisMode == "Body" && visTemplateBody.dirty) {
		visTemplateBody.set(getTemplateBody(template));
		delete visTemplateBody.dirty;
	}
	if (yarnVisMode == "Tube" && visTemplateTubes.dirty) {
		visTemplateTubes.set(getTemplateBody(template));
		delete visTemplateTubes.dirty;
	}

	//update status line:
	{
		let info = "";
		if (template !== null) {
			info += `Template: ${template.longsignature()}`;
		} else {
			info += `No Template`;
		}
		STATUS_LINE.innerText = info;
	}

	visPreviewLines.update();

	gl.lineWidth(1.0 * pixelRatio);
	grid.draw(colorProgram);

	// TODO: support other visualization modes
	if (yarnVisMode == "Body") {
		visTemplateBody.draw(colorProgram);
	} else if (yarnVisMode == "Wire") {
		visTemplateWire.draw(colorProgram);
	} else if (yarnVisMode == "Tube") {
		visTemplateWireCells.draw(colorProgram);

		gl.useProgram(textureProgram.program);
		visTemplateTubes.draw(textureProgram);
		gl.useProgram(colorProgram.program);
	}

	//show "hidden" debug lines also:

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		0.0, 0.0, 0.0, 0.1
	);
	gl.depthFunc(gl.GREATER);
	gl.depthMask(false);
	gl.lineWidth(2.0 * pixelRatio);
	visPreviewLines.draw(colorProgram);

	gl.depthFunc(gl.LESS);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
}

function redraw() {
	const pixelRatio = window.devicePixelRatio;

	let clearColor = [0.1, 0.1, 0.1];

	//make sure canvas size matches element size:
	(function resize() {
		const style = getComputedStyle(canvas);
		window.style = style;

		const width = Math.round(parseFloat(style.width) * pixelRatio);
		const height = Math.round(parseFloat(style.height) * pixelRatio);
		canvas.width = width;
		canvas.height = height;
		gl.viewport(0,0,width,height);
		camera.aspect = width / height;

		// read clearColor from CSS
		const rgbColor = style["background-color"];
		// Use a regular expression to extract the r,g,b components from a string of the form "rgb(r, g, b)".
		// The unescaped parentheses capture the r,g,b values which can be accessed as elements 1,2,3 of the returned match
		const matchResult = rgbColor.match(/^rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+)\)\s*$/);
		if (matchResult.length >= 4) clearColor = [matchResult[1]/255., matchResult[2]/255., matchResult[3]/255.];
	})();

	// Update displayed knitout code if necessary
	// TODO: this should probably happen somewhere else
	if (knitoutCode.dirty) {
		writeHighlightedCode(knitoutCode.text, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
		delete knitoutCode.dirty;
	}

	//update mouse info:
	if (CURSOR.dirty || MOUSE.dirty) setCursorOver();

	//- - - - - - - - - - - - - - - - - - - -
	postprocess.resize(canvas.width, canvas.height);

	postprocess.begin_depth_shaded();
	gl.clearColor(clearColor[0], clearColor[1], clearColor[2], 1.0);

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	gl.useProgram(colorProgram.program);

	gl.uniformMatrix4fv(
		colorProgram.uniformLocations.LOCAL_TO_CLIP,
		false,
		computeMVP()
	);

	const lightDir = gm.normalize(gm.add(camera.computeUp(),camera.computeOut()));
	gl.uniform3f(
		colorProgram.uniformLocations.HEMI_DIRECTION,
		lightDir[0], lightDir[1], lightDir[2]
	);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		1.0, 1.0, 1.0, 1.0
	);

	// if we're drawing tubes, set up the texture program as well
	if (yarnVisMode == "Tube") {

		gl.useProgram(textureProgram.program);
		gl.uniformMatrix4fv(
			textureProgram.uniformLocations.LOCAL_TO_CLIP,
			false,
			computeMVP()
		);
		const lightDir = gm.normalize(gm.add(camera.computeUp(),camera.computeOut()));
		gl.uniform3f(
			textureProgram.uniformLocations.HEMI_DIRECTION,
			lightDir[0], lightDir[1], lightDir[2]
		);
		gl.uniform4f(
			textureProgram.uniformLocations.TINT,
			1.0, 1.0, 1.0, 1.0
		);

		const show_texture = document.getElementById("show-yarn-direction-form")[0].checked;
		gl.uniform1f(
			textureProgram.uniformLocations.TEX_STRENGTH,
			(show_texture ? 1 : 0)
		);
		gl.uniform1f(
			textureProgram.uniformLocations.selectedCellID,
			// HACK: don't highlight selected cell in template view mode. Really, we should probably make CURSOR.over depend on mode
			(CURSOR.over === null || viewMode === ViewMode.Template) ?  -1. : CURSOR.over.cellID
		);
		gl.uniform4f(
			textureProgram.uniformLocations.TINT,
			1.0, 1.0, 1.0, 1.0
		);
		gl.uniform4f(
			textureProgram.uniformLocations.selectedColor,
			visTubes.selectedColor[0], visTubes.selectedColor[1], visTubes.selectedColor[2], visTubes.selectedColor[3]
		);

		// pass in texture
		// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, window.arrowTexture);
		gl.uniform1i(textureProgram.uniformLocations.uSampler, 0);

		gl.useProgram(colorProgram.program);
	}
	
	// draw yarn
	if (viewMode === ViewMode.Pattern) {
		redrawPatternDepthShaded(pixelRatio);
	} else if (viewMode === ViewMode.Template) {
		redrawTemplate(pixelRatio);
	}

	// prepare for UI pass (only used in pattern mode)
	postprocess.begin_non_depth_shaded();
	gl.clearColor(clearColor[0], clearColor[1], clearColor[2], 1.0);

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	gl.useProgram(colorProgram.program);

	// if in pattern mode, draw UI separately
	if (viewMode === ViewMode.Pattern) {
		redrawPatternNonDepthShaded(pixelRatio);
	}

	postprocess.end();
	//- - - - - - - - - - - - - - - - - - - -

	
}

function requestRedraw() {
	if (requestRedraw.requested) return;
	requestRedraw.requested = true;
	window.requestAnimationFrame(function(ts){
		delete requestRedraw.requested;
		redraw();
	});
}
window.requestRedraw = requestRedraw;

resetCamera();
requestRedraw();

window.addEventListener('resize', requestRedraw);

async function init() {
	{
		console.log(`Fetching library...`);
		//const request = await fetch('solid-knitting.library');
		const request = await fetch('block-library/blocks.json');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.library = sv.Library.fromArrayBuffer(arrayBuffer);
		listTemplates(window.library.templates);

		//hack-y way of selecting first template:
		window.template = null;
		nextTemplate();


		let info = 'Library contains:';
		for (let name of Object.keys(library.templates).sort()) {
			info += '\n   ' + name;
		}
		console.log(info);
	}

	{
		console.log(`Fetching body...`);
		const request = await fetch('cube-3x3.body');
		// const request = await fetch('example.body');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.body = sv.Body.fromArrayBuffer(arrayBuffer, library);
		allocateSpots();
	}

	{
		console.log(`Loading textures...`)
		// Load texture
		window.arrowTexture = loadTexture(gl, "images/arrow.png");
		// Flip image pixels into the bottom-to-top order that WebGL expects.
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

	}

	bodyDirty();
	resetCamera();
	requestRedraw();
}

init();

</script>

</body>
</html>
