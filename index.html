<!DOCTYPE html>
<html>
<head>
<title>Solid Knitting UI</title>
<style>
body {
	padding:0;
	margin:0;
}
#dropTarget {
	position:fixed;
	left:0;
	bottom:0;
	width:100%;
	height:100%;

	background:#ccc;
	outline:4px dashed #eee;
	outline-offset:-20px;
	z-index:100;
	visibility:hidden;
}
#dropTarget.active {
	visibility:visible;
	background:#eee;
	outline-color:#ccc;
}
#file {
	display:none;
}
#fileLabel span {
	cursor:pointer;
	text-decoration:underline;
}

#views {
	display:grid;
	width:99vw;
	height:99vh;

	grid-template-columns: 1fr auto ;
	grid-template-rows: auto 1.0fr ;

	/*background: #0008 ;*/
}
#view-controls {
	grid-column: 1 / 3 ;
	grid-row: 1 ;
	font-size: 16px;
	line-height:16px;
	padding: 5px 10px;
	/*background: #f008 ;*/
}
#view-3d {
	grid-column: 1 ;
	grid-row: 2 ;
	position:relative;
	/*background: #0f08 ;*/
}
#canvas {
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
}
#view-library {
	grid-column: 2 ;
	grid-row: 2 ;
	/*background: #00f8 ;*/
}
#view-library h1 {
	font-size:20px;
	line-height:20px;
	padding:0;
	margin:0 5px;
}
#library {
	display:block;
	list-style:none;
	margin:0;
	padding:0;
}
#library li {
	display:block;
	margin:0.5em 1.0em;
	padding:0;
}
</style>
</head>
<body>

<div id="views">

<!-- controls bar at the top of the window -->
<div id="view-controls">
<h1 id="file-name">No File Loaded</h1>
<input id="file" type="file" />
<label id="fileLabel" for="file"><span>Choose a .blocks file</span> or drag one into the window to load it.</label>
<!-- <button id="benchmark">benchmark</button>
<span id="benchmark-result"></span> -->
</div>

<!-- 3d view -->
<div id="view-3d">
<canvas id="canvas" width="120" height="120"></canvas>
</div>

<!-- library panel -->
<div id="view-library">
<h1>Blocks:</h1>
<ul id="library">
</ul>
</div>

</div>

<!-- full-window drop target -->
<div id="dropTarget"></div>

<!-- File loading code -->
<script>
// TODO: Consider moving each script into its own module for the sake of code
// clarity. 
//-----------------------------------------------------------------------------
// File loading code

window.currentFile = null;

function setFilename(name) {
	document.getElementById("file-name").firstChild.textContent = name;
}
function readFile(file) {
	console.log("Attempting to read file: '" + file.name + "'");
	setFilename(file.name);

	if (readFile.reader) {
		readFile.reader.abort();
		delete readFile.reader;
	}

	let reader = readFile.reader = new FileReader();
	reader.onload = function(){
		console.log("File was " + reader.result.byteLength + " bytes long.");
		window.blocks = sv.Blocks.fromArrayBuffer(reader.result);

		resetCamera();
		requestRedraw();
		window.currentFile = file;
	};
	reader.readAsArrayBuffer(file);
}

var dropTarget = document.getElementById("dropTarget");
//dragging into the window also loads files:
dropTarget.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('dragleave', function(evt){
	dropTarget.classList.remove("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('drop', function(evt){
	dropTarget.classList.remove("active");
	try {
		file.value = "";
		window.currentFile = null;
		readFile(evt.dataTransfer.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});

//dragging into the window shows the target:
document.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});

var file = document.getElementById("file");
file.addEventListener('change', function(evt){
	try {
		window.currentFile = null;
		readFile(file.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});
file.addEventListener('click', function(evt){
	file.value = ""; //reset so 'change' event fires
});
</script>

<!-- Solid Knitting UI code -->
<script type="module">
'use strict';

import * as gm from './code/gm.mjs';
window.gm = gm; //DEBUG

import * as sv from './code/sv.mjs';

window.library = new sv.Library();
window.body = new sv.Body();

import {Geometry, Program} from './code/gl.mjs';

//-----------------------------------------------------------------------------
// Adapted from yarn visualizer code (from smobj)
// NOTE: based largely on the MDN WebGL tutorials at:
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL

const canvas = document.getElementById("canvas");
const gl = canvas.getContext('webgl');
window.gl = gl; //DEBUG

//------- camera -------
const camera = {
	target:{x:0.0, y:0.0, z:0.0},
	radius:2.5,
	azimuth:0.0,
	elevation:0.0,
	fovy:45.0,
	aspect:1.0
};

camera.computeUp = function camera_computeUp() {
	return {
		x:Math.cos(this.azimuth)*-Math.sin(this.elevation),
		y:Math.sin(this.azimuth)*-Math.sin(this.elevation),
		z:Math.cos(this.elevation)
	};
};

camera.computeRight = function camera_computeRight() {
	return {
		x:-Math.sin(this.azimuth),
		y:Math.cos(this.azimuth),
		z:0.0
	};
};

camera.computeOut = function camera_computeOut() {
	return {
		x:Math.cos(this.azimuth)*Math.cos(this.elevation),
		y:Math.sin(this.azimuth)*Math.cos(this.elevation),
		z:Math.sin(this.elevation)
	};
};

camera.computeAt = function camera_computeAt() {
	const out = this.computeOut();
	return {
		x:this.target.x+this.radius*out.x,
		y:this.target.y+this.radius*out.y,
		z:this.target.z+this.radius*out.z
	};
};

function resetCamera() {
	let min = {x:Infinity, y:Infinity, z:Infinity};
	let max = {x:-Infinity, y:-Infinity, z:-Infinity};

	//TOOD: compute bounding box

	if (min.x > max.x) {
		//for now, just some default:
		min.x = -10.0; min.y = -10.0; min.z = -10.0;
		max.x =  10.0; max.y =  10.0; max.z =  10.0;
	}

	camera.target.x = 0.5 * (min.x + max.x);
	camera.target.y = 0.5 * (min.y + max.y);
	camera.target.z = 0.5 * (min.z + max.z);

	//console.log("Range: ",min,max);

	camera.radius = 0.5 * (max.y - min.y) / Math.tan(0.5 * camera.fovy * Math.PI / 180.0) + 0.5 * (max.z - min.z);
	camera.azimuth = Math.PI / 6.0;
	camera.elevation = Math.PI / 4.0;

	requestRedraw();
}

//--- controls ---

const MOUSE = {x:NaN, y:NaN, over:null, grid:null};
window.MOUSE = MOUSE; //DEBUG

let camFlipX = false; //used for camera rotation control

function mouseRay() {
	const origin = camera.computeAt();
	const direction = {};

	//compute ray direction through mouse:
	const o = camera.computeOut();
	const r = camera.computeRight();
	const u = camera.computeUp();
	const rh = Math.tan(0.5 * camera.fovy / 180.0 * Math.PI); //half of the image plane height
	const rw = rh * camera.aspect; //half of the image plane width
	direction.x = -o.x + rw * r.x * MOUSE.x + rh * u.x * MOUSE.y;
	direction.y = -o.y + rw * r.y * MOUSE.x + rh * u.y * MOUSE.y;
	direction.z = -o.z + rw * r.z * MOUSE.x + rh * u.z * MOUSE.y;

	return {origin, direction};
}

function setMouseOver() {
	MOUSE.over = null;
	MOUSE.grid = null;
	if (MOUSE.x !== MOUSE.x) return;
	const ray = mouseRay();

	let close = Infinity;

	{ //grid (at z = 0):
		const ofs = ray.origin.z;
		const step = ray.direction.z;
		if ((ofs < 0 && step > 0) || (ofs > 0 && step < 0)) {
			const t = -ofs / step;
			if (t < close) {
				close = t;
				MOUSE.over = null;
				MOUSE.grid = {
					x:ray.origin.x + ray.direction.x * t,
					y:ray.origin.y + ray.direction.y * t,
					z:ray.origin.z + ray.direction.z * t
				};
			}
		}
	}
	

	//faces of cells:
	function isect(a,b,c, cell,face) {
		const perp = cross(sub(b, a), sub(c, a));

		//offset of the start of the ray from the plane of the triangle:
		const ofs = dot(perp, sub(ray.origin, a));

		//change in offset when moving along direction:
		const step = dot(perp, ray.direction);

		//if can't get to plane of triangle, can't intersect:
		if (step === 0) return;
		if (ofs <= 0 && step <= 0) return;
		if (ofs >= 0 && step >= 0) return;

		//if can't get to plane in time, can't intersect:
		const t = -ofs / step;
		if (t >= close) return;

		//move point to plane of triangle:
		const p = {
			x:ray.origin.x + ray.direction.x * t,
			y:ray.origin.y + ray.direction.y * t,
			z:ray.origin.z + ray.direction.z * t
		};

		//console.log(`Close to zero(?): ${dot(perp, sub(p,a))}`); //DEBUG

		//barycentric coords:
		const wa = dot(perp, cross(sub(c,b), sub(p,b)));
		const wb = dot(perp, cross(sub(a,c), sub(p,c)));
		const wc = dot(perp, cross(sub(b,a), sub(p,a)));

		//outside the triangle:
		if (wa < 0 || wb < 0 || wc < 0) return;

		close = t;
		MOUSE.over = {cell, face};
		MOUSE.grid = null;
	}

	for (const cell of body.cells) {
		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			const face = cell.template.faces[fi];
			for (let i = 2; i < face.indices.length; ++i) {
				const a = cell.vertices[face.indices[0]];
				const b = cell.vertices[face.indices[i-1]];
				const c = cell.vertices[face.indices[i]];
				isect(a,b,c, cell,fi);
			}
		}
	}
}

//mouse in elt-is-[-1,1]x[-1,1] space:
function relativeMouse(evt, elt) {
	//based on: https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event
	const rect = elt.getBoundingClientRect();
	return {
		x:2.0 * (evt.clientX - rect.left) / rect.width - 1.0,
		y:-2.0 * (evt.clientY - rect.top) / rect.height + 1.0
	};
}

canvas.addEventListener('wheel', function(evt){
	evt.preventDefault();
	let amt = evt.deltaY;
	if (evt.deltaMode === 0x01) amt *= 16.0;
	const zoom = Math.pow(0.5, -0.003 * amt);
	camera.radius *= zoom;
	if (camera.radius < 1.0) camera.radius = 1.0;
	if (camera.radius > 1000.0) camera.radius = 1000.0;
	requestRedraw();
	return false;
});

canvas.addEventListener('mousedown', function(evt){
	const mouse = relativeMouse(evt, canvas);
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	camFlipX = (camera.computeUp().z < 0.0);
	evt.preventDefault();
	return false;
});

canvas.addEventListener('mousemove', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (MOUSE.x === MOUSE.x) {
		if (evt.buttons & 1) {
			if (evt.shiftKey) {
				const up = camera.computeUp();
				const right = camera.computeRight();

				const x = camera.radius * (mouse.x - MOUSE.x) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI) * camera.aspect;
				const y = camera.radius * (mouse.y - MOUSE.y) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI);

				camera.target.x -= right.x * x + up.x * y;
				camera.target.y -= right.y * x + up.y * y;
				camera.target.z -= right.z * x + up.z * y;
			} else {
				const deltaToAngle = 2.0 * camera.fovy / 180.0 * Math.PI;
				camera.azimuth += (camFlipX ? -1.0 : 1.0) * -(mouse.x - MOUSE.x) * camera.aspect * deltaToAngle;
				camera.elevation -= (mouse.y - MOUSE.y) * deltaToAngle;
			}
			requestRedraw();
		}
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	setMouseOver();
	requestRedraw(); //needed if we want to draw mouse cursor, maybe not generally needed
	evt.preventDefault();
	return false;
});

canvas.addEventListener('mouseup', function(evt){
	MOUSE.x = NaN;
	MOUSE.y = NaN;
	evt.preventDefault();
	return false;
});

window.addEventListener('keydown', function(evt){
	if (evt.code === 'Space') {
		body.relax();
		visBody.set(body);
		requestRedraw();
	} else if (evt.code == 'KeyA') {
		addCell();
	} else if (evt.code == 'KeyX') {
		deleteCell();
	}
});

// TODO: Consider moving each script into its own module for the sake of code
// clarity. 

// Solid knitting interface code. 

// Very buggy, please don't mind my debug notes: 
/**
 * addCell (): 
 * Adds cell adjacent to selected face. */
function addCell() {
	const cell = MOUSE.over.cell;
	const face = MOUSE.over.face; 

	// Only connect if hovered face is not connected. 
	if (!cell.connections[face]) {
		// TODO: Delete this, this is just for debugging face connections. 
		//const faceRep = cell.template.face[face];
		
		console.log("Valid face connection!");
		console.log("face: " + face);
		// Create new block vertices. 
		// For now using the same block type as current selected block.
		

		console.log(face.indices);

		const newVertices = [
			[2.5,0,2], [2.5,0,4], [2.5,2,2], [2.5,2,4],
			[4.5,0,2], [4.5,0,4], [4.5,2,2], [4.5,2,4]
		]
		
		// TODO: Update cell template based on selected block type.
		// For now we are using the same template as the neighboring block. This will change in the future. 
		const newCellTemplate = structuredClone(cell.template);

		// Update connections to highlight new neighbors.		
		const newCell = { 
			template: newCellTemplate, 
			vertices: newVertices,
			connections: [{
					cell: cell, 
					face: face
				}, null, null, null, null, null]
		}

		// Update current selected face to be connected.
		// TODO: Figure out how to connect based on specific face types. 

		cell.connections[face] =
				{
					cell: newCell, 
					face: 0
				}; // updating logic. 

		// Push block onto Body. 
		body.cells.push(newCell); 
		console.log(body.cells);
	} else {
		// TODO: Delete this, this is just for debugging face connections. 
		console.log("Face connection is not valid!");
	}

	// TODO: Add some "current block type" and have some keys or UI to change it
	// for we are just using the first block in the library.

	//update UI and redraw:
	setMouseOver();
	visBody.set(body);
	requestRedraw();
}


/**
 * deleteCell (): 
 * Deletes currently selected cell, regardless of face type. 
 * Consider: When cell is selected to delete a box, instead of highlighting
 * selected face, we should highlight selected cell. */
function deleteCell() {
	if (!MOUSE.over) {
		return;
	}

	const cell = MOUSE.over.cell;

	const cellIndex =  body.cells.indexOf(cell);
	const cellConnections = body.cells[cellIndex].connections;

	// Update all connections referencing current cell.
	for (let i = 0; i < cellConnections.length; i++) {
		if(cellConnections[i] != null){
			const currCell = cellConnections[i].cell;
			const currFace = cellConnections[i].face;
			currCell.connections[currFace] = null;
		}
	}

	// Remove current cell from body. 
	body.cells.splice(cellIndex, 1);

	// Update UI and redraw:
	setMouseOver();
	visBody.set(body);
	requestRedraw();
}

//--- vector math library ---
//TODO: clean this up and move to its own module

function add(a,b) {
	return {x:a.x+b.x, y:a.y+b.y, z:a.z+b.z};
}
function sub(a,b) {
	return {x:a.x-b.x, y:a.y-b.y, z:a.z-b.z};
}
function dot(a, b) {
	return a.x * b.x + a.y * b.y + a.z * b.z;
}
function cross(a, b) {
	return {
		x: a.y * b.z - a.z * b.y,
		y: a.z * b.x - a.x * b.z,
		z: a.x * b.y - a.y * b.x
	};
}
function normalize(vec) {
	var len = Math.sqrt(dot(vec, vec));
	return { x:vec.x / len, y:vec.y / len, z:vec.z / len };
}
function lookAt(eye, target, up) {
	var out = normalize({ x:eye.x - target.x, y:eye.y - target.y, z:eye.z - target.z });
	var proj = dot(up, out);
	up = normalize({ x:up.x - proj * out.x, y:up.y - proj * out.y, z:up.z - proj * out.z });

	var right = cross(up, out);

	var offset = { x: -dot(eye, right), y: -dot(eye, up), z: -dot(eye, out) };

	return new Float32Array([
		right.x, up.x, out.x, 0.0,
		right.y, up.y, out.y, 0.0,
		right.z, up.z, out.z, 0.0,
		offset.x, offset.y, offset.z, 1.0
	]);
}

function perspective(fovy, aspect, zNear) {
	var f = 1 / Math.tan(fovy/2 * Math.PI / 180.0);
	return new Float32Array([
		f / aspect, 0.0, 0.0, 0.0,
		0.0, f, 0.0, 0.0,
		0.0, 0.0, -1, -1.0,
		0.0, 0.0,-2.0 * zNear, 0.0
	]);
}
function mul(A, B) {
	var out = new Float32Array(16);
	for (var r = 0; r < 4; ++r) {
		for (var c = 0; c < 4; ++c) {
			var val = 0.0;
			for (var k = 0; k < 4; ++k) {
				val += A[k * 4 + r] * B[c * 4 + k];
			}
			out[4 * c + r] = val;
		}
	}
	return out;
}

function computeMVP() {
	/*//DEBUG:
	return new Float32Array([
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0
	]);*/
	const P = perspective(camera.fovy, camera.aspect, 0.1);
	const up = camera.computeUp();
	const MV = lookAt(
		camera.computeAt(),
		camera.target,
		up
	);
	return mul(P, MV);
}

//------- benchmark -------

/*
function benchmark() {
	console.log("Running benchmark....");

	//Okay, how to benchmark renderer? Consistent frame size, camera position, yarns.

	canvas.style.width = "1024px";
	canvas.style.height = "1024px";

	setBenchmarkYarns();

	camera.target = {x:0.0, y:0.0, z:0.0};
	camera.radius = 37;
	camera.azimuth = 0.0;
	camera.elevation = 0.0;
	camera.fovy = 60.0;
	camera.aspect = 1.0;

	let before = performance.now();
	let iters = 0;
	while (iters < 1000) {
		++iters;
		redraw();
		gl.finish();
		let after = performance.now();
		if (after - before > 2000) break;
	}
	let total = performance.now() - before;
	console.log("Did " + iters + " iterations in " + total + "ms.");
	let result = iters.toString() + " iterations, avg " + total/iters + "ms per";
	document.getElementById("benchmark-result").innerText = result;
}

document.getElementById("benchmark").addEventListener('click', benchmark);
*/

//------- rendering -------

//very simple shader program for vertex-colored things:
const colorProgram = new Program(gl,
`
	uniform mat4 LOCAL_TO_CLIP;

	attribute vec4 Position;
	attribute vec3 Normal;
	attribute vec4 Color;

	varying vec4 color;
	varying vec3 normal;

	void main() {
		gl_Position = LOCAL_TO_CLIP * Position;
		color = Color;
		normal = Normal;
	}
`,`
	uniform highp vec3 HEMI_DIRECTION;
	varying lowp vec4 color;
	varying highp vec3 normal;
	void main() {
		highp vec3 n = normalize(normal);
		//upper dome light:
		highp vec3 light = mix(vec3(0.1), vec3(1.0), 0.5*dot(n, HEMI_DIRECTION)+0.5);
		gl_FragColor = vec4(color.rgb * light, color.a);
	}
`);
window.colorProgram = colorProgram; //DEBUG


//when using a data view to store Float32 values, do they need to be marked as little endian?
const FLOAT32_LITTLE_ENDIAN = function() {
	let array = new ArrayBuffer(4);
	let f32 = new Float32Array(array);
	let data = new DataView(array);
	f32[0] = 1.0;
	if (data.getFloat32(0, false) === f32[0]) {
		assert(data.getFloat32(0, true) !== f32[0]);
		return false;
	} else if (data.getFloat32(0, true) === f32[0]) {
		assert(data.getFloat32(0, false) !== f32[0]);
		return true;
	}
};

class Grid extends Geometry {
	constructor() {
		const BYTES_PER_ATTRIB = 4*2 + 1*4;
		const RADIUS = 10;

		const arrayBuffer = new ArrayBuffer(4*(2*RADIUS+1) * BYTES_PER_ATTRIB);
		const data = new DataView(arrayBuffer);

		let dataOffset = 0;

		function attrib(x,y, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		for (let x = -RADIUS; x <= RADIUS; ++x) {
			attrib(x,-RADIUS, 0x888888ff);
			attrib(x, RADIUS, 0x888888ff);
		}
		for (let y = -RADIUS; y <= RADIUS; ++y) {
			attrib(-RADIUS,y, 0x888888ff);
			attrib( RADIUS,y, 0x888888ff);
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		const buffer = gl.createBuffer();
		const count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);

		const attribs = {
			Position:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*2},
			Normal:[0.0, 0.0, 1.0]
		};

		super(gl, attribs, gl.LINES, count);
	}
}
const grid = new Grid();
window.grid = grid; //DEBUG

//helper for color conversion from '#rrggbb', '#rrggbbaa', '#rgb', and '#rgba' to 0xrrggbbaa
function css2Uint32(color) {
	let val;
	if        (color.length === 9) {
		val = parseInt('0x' + color.substr(1));
	} else if (color.length === 7) {
		val = parseInt('0x' + color.substr(1)) * 256 + 255;
	} else if (color.length === 5) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		const a = (val & 0x000f);
		//why are these not bit-shifts? because those coerce numbers to *signed* int32s integers (vs remaining float64's, which have 50-ish bits of integer precision)
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + (a * 16 + a);
	} else if (color.length === 4) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + 255;
	}
	return val;
}

class VisBody extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 4*3 + 1*4; //Position, Normal, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3},
		};

		super(gl, attribs, gl.TRIANGLES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(blocks) {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				totalAttribs += 3 * (face.indices.length - 2);
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, nx,ny,nz, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, nx, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, ny, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, nz, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}
		
		function triangle(va,vb,vc, color) {
			let n = normalize(cross(sub(vb, va), sub(vc, va)));
			attrib(va.x,va.y,va.z, n.x,n.y,n.z, color);
			attrib(vb.x,vb.y,vb.z, n.x,n.y,n.z, color);
			attrib(vc.x,vc.y,vc.z, n.x,n.y,n.z, color);
		}
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				//TODO: compute normals in some smooth way
				for (let i = 2; i < face.indices.length; ++i) {
					triangle(
						cell.vertices[face.indices[0]], cell.vertices[face.indices[i-1]], cell.vertices[face.indices[i]],
						css2Uint32(face.color));
					
				}
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}
const visBody = new VisBody();
window.visBody = visBody; //DEBUG

class VisDebug extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisDebug.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer;
	}
	update() {
		const BYTES_PER_ATTRIB = VisDebug.BYTES_PER_ATTRIB;

		let attribs = []; //x,y,z,color

		function line(a,b,color) {
			attribs.push(a.x,a.y,a.z,color);
			attribs.push(b.x,b.y,b.z,color);
		}

		//----- make debug lines ----

		//axes:
		line({x:0,y:0,z:0},{x:5,y:0,z:0}, 0xff0000ff);
		line({x:0,y:0,z:0},{x:0,y:5,z:0}, 0x00ff00ff);
		line({x:0,y:0,z:0},{x:0,y:0,z:5}, 0x0000ffff);

		//mouse cursor:
		if (MOUSE.x === MOUSE.x) {
			const ray = mouseRay();
			const r = camera.computeRight();
			const u = camera.computeUp();
			r.x *= 0.01; r.y *= 0.01; r.z *= 0.01;
			u.x *= 0.01; u.y *= 0.01; u.z *= 0.01;
			const c = add(ray.origin, ray.direction);
			line(add(c,r), sub(c,r), 0xffff00ff);
			line(add(c,u), sub(c,u), 0xffff00ff);
		}

		//currently hovered face:
		if (MOUSE.over !== null) {
			const cell = MOUSE.over.cell;
			const face = cell.template.faces[MOUSE.over.face];
			for (let i = 0; i < face.indices.length; ++i) {
				line(cell.vertices[face.indices[(i == 0 ? face.indices.length : i) - 1]], cell.vertices[face.indices[i]], 0xffff0088);
			}
		}

		//currently hovered grid cell:
		if (MOUSE.grid !== null) {
			const x = Math.floor(MOUSE.grid.x);
			const y = Math.floor(MOUSE.grid.y);

			line({x:x, y:y, z:0}, {x:x+1,y:y, z:0}, 0xff00ffff);
			line({x:x+1, y:y, z:0}, {x:x+1,y:y+1, z:0}, 0xff00ffff);
			line({x:x+1, y:y+1, z:0}, {x:x,y:y+1, z:0}, 0xff00ffff);
			line({x:x, y:y+1, z:0}, {x:x,y:y, z:0}, 0xff00ffff);
		}


		//---- copy debug lines to buffer for drawing ----

		//copy attribs to a formatted buffer:
		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * (attribs.length / 4));
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		for (let i = 0; i < attribs.length; i += 4) {
			data.setFloat32(dataOffset, attribs[i+0], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+1], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+2], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, attribs[i+3], false); dataOffset += 4;
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STREAM_DRAW);
	}
}
const visDebug = new VisDebug();

function redraw() {
	const pixelRatio = window.devicePixelRatio;

	//make sure canvas size matches element size:
	(function resize() {
		const style = getComputedStyle(canvas);
		window.style = style;

		const width = Math.round(parseFloat(style.width) * pixelRatio);
		const height = Math.round(parseFloat(style.height) * pixelRatio);
		canvas.width = width;
		canvas.height = height;
		gl.viewport(0,0,width,height);
		camera.aspect = width / height;
	})();

	visDebug.update();

	gl.clearColor(0.1, 0.1, 0.1, 1.0);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	gl.useProgram(colorProgram.program);

	gl.uniformMatrix4fv(
		colorProgram.uniformLocations.LOCAL_TO_CLIP,
		false,
		computeMVP()
	);

	const lightDir = normalize(add(camera.computeUp(),camera.computeOut()));
	gl.uniform3f(
		colorProgram.uniformLocations.HEMI_DIRECTION,
		lightDir.x, lightDir.y, lightDir.z
	);

	gl.lineWidth(2.0 * pixelRatio);
	visDebug.draw(colorProgram);

	gl.lineWidth(1.0 * pixelRatio);
	grid.draw(colorProgram);

	visBody.draw(colorProgram);
}

function requestRedraw() {
	if (requestRedraw.requested) return;
	requestRedraw.requested = true;
	window.requestAnimationFrame(function(ts){
		delete requestRedraw.requested;
		redraw();
	});
}

resetCamera();
requestRedraw();

window.addEventListener('resize', requestRedraw);

async function init() {
	{
		console.log(`Fetching library...`);
		const request = await fetch('solid-knitting.library');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.library = sv.Library.fromArrayBuffer(arrayBuffer);
	}

	{
		console.log(`Fetching body...`);
		const request = await fetch('example.body');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.body = sv.Body.fromArrayBuffer(arrayBuffer, library);
	}

	visBody.set(window.body);

	resetCamera();
	requestRedraw();
}

init();

</script>
</body>
</html>
